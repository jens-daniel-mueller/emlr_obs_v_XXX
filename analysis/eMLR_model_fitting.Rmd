---
title: "eMLR - model fitting"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}
params_local <-
  read_rds(here::here("data/auxillary",
                       "params_local.rds"))

```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

path_version_figures  <-
  paste(path_observations,
        params_local$Version_ID,
        "/figures/",
        sep = "")
```

```{r load_libraries_specific, include = FALSE}
library(lubridate)
library(GGally)
library(olsrr)
library(knitr)
library(kableExtra)
library(broom)
library(corrr)
library(GGally)
library(gt)
```

# Required data

Required are:

- cleaned and prepared GLODAPv2_2020 file

```{r read_GLODAP_used_for_fitting}

GLODAP <-
  read_csv(paste(path_version_data,
                 "GLODAPv2.2020_MLR_fitting_ready.csv",
                 sep = ""))

```

# Predictor combinations

Find all possible combinations of following considered predictor variables:  

- `r params_local$MLR_predictors`

```{r eMLR_find_all_predictor_combinations, results='hide'}

# the following code is a workaround to find all predictor combinations
# using the olsrr package and fit all models for one era, slab, and basin

i_basin <- unique(GLODAP$basin)[1]
i_era   <- unique(GLODAP$era)[1]

# subset one basin and era for fitting
GLODAP_basin_era <- GLODAP %>%
  filter(basin == i_basin, era == i_era)

i_gamma_slab <- unique(GLODAP_basin_era$gamma_slab)[1]
print(i_gamma_slab)

# subset one gamma slab
GLODAP_basin_era_slab <- GLODAP_basin_era %>%
  filter(gamma_slab == i_gamma_slab)

# fit the full linear model, i.e. all predictor combinations
lm_full <- lm(paste(
  params_local$MLR_target,
  paste(params_local$MLR_predictors, collapse = " + "),
  sep = " ~ "
),
data = GLODAP_basin_era_slab)

# fit linear models for all possible predictor combinations
# unfortunately, this functions does not provide model coefficients (yet)
lm_all <- ols_step_all_possible(lm_full)

# convert to tibble
lm_all <- as_tibble(lm_all)

# format model formula
lm_all <- lm_all %>% 
  select(n, predictors) %>% 
  mutate(model = str_replace_all(predictors, " ", " + "),
         model = paste(params_local$MLR_target, "~", model))

# remove helper objects
rm(i_gamma_slab,
   i_era,
   i_basin,
   GLODAP_basin_era,
   GLODAP_basin_era_slab,
   lm_full)

```

# Apply predictor threshold

Select combinations with a total number of predictors in the range:  

- Minimum: `r params_local$MLR_predictors_min`  
- Maximum: `r params_local$MLR_predictors_max`

```{r apply_MLR_predictor_threshold}

lm_all <- lm_all %>% 
  filter(n >= params_local$MLR_predictors_min,
         n <= params_local$MLR_predictors_max)

```

This results in a total number of MLR models of:  

- `r nrow(lm_all)`

# Fit all models

Individual linear regression models were fitted for the chosen target variable:  

- `r params_local$MLR_target`

as a function of each predictor combination. Fitting was performed separately within each basin, era, and slab. Model diagnostics, such as the root mean squared error (RMSE), were calculated for each fitted model.

```{r fit_all_models_purrr, results='hide'}

GLODAP %>% 
  # filter(basin %in% unique(GLODAP$basin)[1],
  #        era %in% unique(GLODAP$era)[c(1,2)],
  #        gamma_slab %in% unique(GLODAP$gamma_slab)[c(5,6)]) %>%
  filter_all(any_vars(is.na(.)))

GLODAP_nested <- GLODAP %>% 
  # filter(basin %in% unique(GLODAP$basin)[1],
  #        era %in% unique(GLODAP$era)[c(1,2)],
  #        gamma_slab %in% unique(GLODAP$gamma_slab)[c(5,6)]) %>%
  drop_na() %>% 
  group_by(gamma_slab, era, basin) %>% 
  nest()

GLODAP_nested_lm <- expand_grid(
  GLODAP_nested,
  lm_all
)

GLODAP_nested_lm_fit <- GLODAP_nested_lm %>% 
  mutate(
    fit = map2(.x = data, .y = model, 
               ~ lm(as.formula(.y), data = .x)),
    tidied = map(fit, tidy),
    glanced = map(fit, glance),
    augmented = map(fit, augment)
  )

print(object.size(GLODAP_nested), units = "MB")
print(object.size(GLODAP_nested_lm), units = "MB")
print(object.size(GLODAP_nested_lm_fit), units = "MB")

GLODAP_glanced <- GLODAP_nested_lm_fit %>%
  select(-c(data, fit, tidied, augmented)) %>%
  unnest(glanced)

# GLODAP_glanced <- GLODAP_glanced %>% 
#   mutate(rmse = sqrt ( (sigma * df.residual) / nobs) )


GLODAP_tidy <- GLODAP_nested_lm_fit %>%
  select(-c(data, fit, glanced, augmented)) %>%
  unnest(tidied)

GLODAP_augmented <- GLODAP_nested_lm_fit %>% 
  select(-c(data, fit, tidied, glanced)) %>% 
  unnest(augmented) 

print(object.size(GLODAP_augmented), units = "MB")

GLODAP_glanced_rmse <- GLODAP_augmented %>%
  group_by(gamma_slab, era, basin, model) %>%
  summarise(rmse = sqrt(c(crossprod(.resid)) / length(.resid))) %>%
  ungroup()

GLODAP_glanced <- full_join(GLODAP_glanced, GLODAP_glanced_rmse)
rm(GLODAP_glanced_rmse)


# GLODAP_data <- GLODAP_nested_lm_fit %>% 
#   select(-c(fit, tidied, glanced, augmented)) %>% 
#   unnest(data) 


# # find max predictor correlation
# i_cor_max <- GLODAP_basin_era_slab %>%
#   select(!!!syms(str_split(i_predictors, " ",
#                            simplify = TRUE))) %>%
#   correlate(quiet = TRUE) %>%
#   select(-term) %>%
#   abs() %>%
#   max(na.rm = TRUE)
# 
# 
# # calculate maximum residual
# i_resid_max <- max(abs(i_lm_fit$residuals))
# 

rm(GLODAP, GLODAP_nested, GLODAP_nested_lm, GLODAP_nested_lm_fit, lm_all)

```


# Prepare coeffcients

Coefficients are prepared for the mapping of Cant and the chosen target variable.


## Predictor selection

Within each basin and slab, the following number of best linear regression models was selected:  

- `r params_local$MLR_number`

The criterion used to select the best models was:

- `r params_local$MLR_criterion`

The criterion was summed up for two adjacent eras, and the models with lowest summed values were selected.


```{r predictor_selection}

# calculate RMSE sum for adjacent eras
lm_all_eras <- GLODAP_glanced  %>%
  select(basin, gamma_slab, model, era, AIC, rmse) %>% 
  arrange(era) %>% 
  group_by(basin, gamma_slab, model) %>% 
  mutate(eras = paste(lag(era), era, sep = " --> "),
         rmse_sum = rmse + lag(rmse),
         aic_sum = AIC + lag(AIC)
         ) %>% 
  ungroup() %>% 
  select(-c(era)) %>% 
  drop_na()

# subset models with lowest summed criterion
# chose which criterion is applied

if (params_local$MLR_criterion == "aic") {
  lm_best_eras <- lm_all_eras %>%
    group_by(basin, gamma_slab, eras) %>%
    slice_min(order_by = aic_sum,
              with_ties = FALSE,
              n = params_local$MLR_number) %>%
    ungroup() %>%
    arrange(basin, gamma_slab, eras, model)
} else {
  lm_best_eras <- lm_all_eras %>%
    group_by(basin, gamma_slab, eras) %>%
    slice_min(order_by = rmse_sum,
              with_ties = FALSE,
              n = params_local$MLR_number) %>%
    ungroup() %>%
    arrange(basin, gamma_slab, eras, model)
}


# print table
lm_best_eras %>% 
  kable() %>%
  add_header_above() %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "400px")

```

## Target variable coefficients

A data frame to map the target variable is prepared.

```{r prepare_model_coefficients_table_target_variable_mapping}

# create table with two era belonging to one eras
eras_forward <- GLODAP_glanced %>%
  arrange(era) %>% 
  group_by(basin, gamma_slab, model) %>% 
  mutate(eras = paste(era, lead(era), sep = " --> ")) %>% 
  ungroup() %>% 
  select(era, eras) %>% 
  unique()

eras_backward <- GLODAP_glanced %>%
  arrange(era) %>% 
  group_by(basin, gamma_slab, model) %>% 
  mutate(eras = paste(lag(era), era, sep = " --> ")) %>% 
  ungroup() %>% 
  select(era, eras) %>% 
  unique()

eras_era <- full_join(eras_backward, eras_forward) %>% 
  filter(str_detect(eras, "NA") == FALSE)

# extend best model selection from eras to era
lm_best <- full_join(
  lm_best_eras %>% select(basin, gamma_slab, model, eras),
  eras_era)

lm_best <- left_join(
  lm_best,
  GLODAP_tidy %>% select(basin, gamma_slab, era, model, term, estimate))

rm(eras_era, eras_forward, eras_backward)

```

## Cant coeffcients

A data frame of coefficient offsets is prepared to facilitate the direct mapping of Cant.

```{r prepare_delta_coefficients_for_cant_mapping}

# subtract coefficients of adjacent era  
lm_best_cant <- lm_best %>%
  arrange(era) %>%
  group_by(basin, gamma_slab, eras, model, term) %>%
  mutate(delta_coeff = estimate - lag(estimate)) %>%
  ungroup() %>%
  arrange(basin, gamma_slab, model, term, eras) %>%
  drop_na() %>%
  select(-c(era,estimate))

# pivot to wide format
lm_best_cant <- lm_best_cant %>%
  pivot_wider(values_from = delta_coeff,
              names_from = term,
              names_prefix = "delta_coeff_",
              values_fill = 0)

```


## Write files

```{r write_model_coefficients_files}

lm_best_target <- lm_best %>% 
  pivot_wider(names_from = "term",
              names_prefix = "coeff_",
              values_from = "estimate",
              values_fill = 0
              )


lm_best_target %>%
  write_csv(paste(path_version_data,
                  "lm_best_target.csv",
                  sep = ""))

lm_best_cant %>%
  write_csv(paste(path_version_data,
                  "lm_best_cant.csv",
                  sep = ""))


```

# Model diagnotics

## Selection criterion vs predictors

The selection criterion (`r params_local$MLR_criterion`) was plotted against the number of predictors (limited to `r params_local$MLR_predictors_min` - `r params_local$MLR_predictors_max`).

### All models

```{r eMLR_predictor_model_quality_all, fig.asp=2, eval=FALSE}

lm_best %>%
  ggplot(aes(as.factor(n_predictors),
             !!sym(params_local$MLR_criterion),
             col = basin)) +
  geom_hline(yintercept = 10) +
  geom_boxplot() +
  facet_grid(gamma_slab~era) +
  scale_color_brewer(palette = "Set1") +
  labs(x="Number of predictors")

```


### Best models

```{r eMLR_predictor_model_quality_best, fig.asp=2, eval=FALSE}

lm_best %>%
  ggplot(aes("",
             !!sym(params_local$MLR_criterion),
             col = basin)) +
  geom_hline(yintercept = 10) +
  geom_boxplot() +
  facet_grid(gamma_slab~era) +
  scale_color_brewer(palette = "Set1") +
  labs(x="Number of predictors pooled")

```


## RMSE correlation between eras

RMSE was plotted to compare the agreement for one model applied to two adjecent eras (ie check whether the same predictor combination performs equal in both eras).

### All models

```{r rmse_correlation_across_eras_all_models, eval=FALSE}

# find max rmse to scale axis
max_rmse <-
  max(c(lm_all_eras$rmse,
        lm_all_eras$rmse_sum - lm_all_eras$rmse))

lm_all_eras %>%
  ggplot(aes(rmse, rmse_sum - rmse, col = gamma_slab)) +
  geom_point() +
  scale_color_viridis_d() +
  coord_equal(xlim = c(0,max_rmse),
              ylim = c(0,max_rmse)) +
  facet_grid(eras ~ basin)

rm(max_rmse)

```


### Best models

```{r rmse_correlation_across_eras_best_models, eval=FALSE}

# find max rmse to scale axis
max_rmse <-
  max(c(lm_best_eras$rmse,
        lm_best_eras$rmse_sum - lm_best_eras$rmse))

lm_best_eras %>%
  ggplot(aes(rmse, rmse_sum - rmse, col = gamma_slab)) +
  geom_point() +
  scale_color_viridis_d() +
  coord_equal(xlim = c(0,max_rmse),
              ylim = c(0,max_rmse)) +
  facet_grid(eras ~ basin)

rm(max_rmse)
```

## Predictor counts

The number of models where a particular predictor was included were counted for each basin, density slab and compared eras

```{r predictor_counts, eval=FALSE}

# calculate cases of predictor used
lm_all_stats <- lm_best_eras_long %>% 
  filter(term != "(Intercept)",
         delta_coeff != 0) %>% 
  group_by(basin, eras, gamma_slab) %>% 
  count(term) %>% 
  ungroup() %>% 
  pivot_wider(values_from = n, names_from = term)

# print table
lm_all_stats %>%
  gt(rowname_col = "gamma_slab",
     groupname_col = c("basin", "eras")) %>% 
  summary_rows(
    groups = TRUE,
    fns = list(total = "sum")
  )

```


## RMSE alternatives

AIC is an alternative criterion to RMSE to judge model quality, but not (yet) taken into account.

```{r aic_vs_rmse_all_models, eval=FALSE}
lm_all_eras %>% 
  ggplot(aes(rmse, aic, col = gamma_slab)) +
  geom_point() +
  scale_color_viridis_d() +
  facet_grid(eras~basin)

```


```{r aic_vs_rmse_selected_models, eval=FALSE}
lm_best_eras %>% 
  ggplot(aes(rmse, aic, col = gamma_slab)) +
  geom_point() +
  scale_color_viridis_d() +
  facet_grid(eras~basin)

```

