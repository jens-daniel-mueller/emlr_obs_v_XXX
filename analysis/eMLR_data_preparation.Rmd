---
title: "eMLR data preparation"
author: "Jens Daniel M체ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
params:
  Version_ID: "v_XXX"
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}

if (params$Version_ID == "v_XXX") {
  params_local <-
    read_rds(here::here("data/auxillary", "params_local.rds"))
  
} else {
  params_local <-
    read_rds(
      file = paste(path_root, "observations",
                   params$Version_ID,
                   "data/params_local.rds",
                   sep = "/")
    )
  }

```

```{r define_paths, include = FALSE}

path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_preprocessing_model    <-
  paste(path_root, "/model/preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

path_version_figures  <-
  paste(path_observations,
        params_local$Version_ID,
        "/figures/",
        sep = "")

path_crossover <- "/nfs/kryo/work/updata/glodapv2_crossover"

```

```{r load_libraries_specific, include = FALSE}
library(marelac)
library(lubridate)
library(broom)
library(seacarb)
library(kableExtra)
library(patchwork)
library(colorspace)
```


```{r select_basin_mask, include=FALSE}

basinmask <- basinmask %>% 
  filter(MLR_basins == params_local$MLR_basins) %>% 
  select(-c(MLR_basins, basin))

```



# Version ID

The results displayed on this site correspond to the Version_ID:

```{r print_version_ID}

params$Version_ID

```

# Required data

## GLODAP

```{r read_GLODAP}

GLODAP <-
  read_csv(paste(path_version_data,
                 "GLODAPv2.2020_clean.csv",
                 sep = ""))

```

## Cant fields

```{r read_cant_files}

S04_cant_3d <-
  read_csv(paste(path_preprocessing,
                 "S04_tcant_3d.csv",
                 sep = ""))

G19_cant_3d <-
  read_csv(paste(path_preprocessing,
                 "G19_dcant_3d.csv",
                 sep = ""))

m94_cant_3d <-
  read_csv(paste0(path_preprocessing_model,
                  "Cant_AD_annual_all_models/",
                  "1994_",
                  params_local$gobm,
                  ".csv"))

m07_cant_3d <-
  read_csv(paste0(path_preprocessing_model,
                  "Cant_AD_annual_all_models/",
                  "2007_",
                  params_local$gobm,
                  ".csv"))

```

## CO2 atm and disequi

```{r read_atm_and_disequilibrium_CO2}

co2_atm <-
  read_csv(paste(path_preprocessing,
                 "co2_atm.csv",
                 sep = ""))

co2_atm_reccap2 <-
  read_csv(paste(path_preprocessing,
                 "co2_atm_reccap2.csv",
                 sep = ""))

if (params_local$gobm %in% c("CESM-ETHZ_v20211122",
                             "FESOM_REcoM_LR_v20211119",
                             "MRI-ESM2-0_v20210830")) {
  delta_pco2_annual_mod <-
    read_csv(
      file = paste(
        path_preprocessing_model,
        "surface_ocean/surface_ocean_disequilibrium/",
        params_local$gobm,
        "_C",
        "_annual.csv",
        sep = ""
      )
    )
} else {
  delta_pco2_annual_mod <-
    read_csv(
      file = paste(
        path_preprocessing_model,
        "surface_ocean/surface_ocean_disequilibrium/",
        "MRI-ESM2-0_v20210830",
        "_C",
        "_annual.csv",
        sep = ""
      )
    )
}

delta_pco2_annual_obs <-
    read_csv(
      file = paste(
        path_preprocessing,
        "OceanSODA_disequilibrium_annual.csv",
        sep = ""
      )
    )

delta_pco2_annual <- bind_rows(
  delta_pco2_annual_mod %>% mutate(data_source = "mod"),
  delta_pco2_annual_obs %>% mutate(data_source = "obs") %>% 
    select(-fgco2_glob_roll)
)

rm(delta_pco2_annual_mod, delta_pco2_annual_obs)
```

## Surface ocean

```{r read_surface_ocean}

### model data

surface_mod <- read_csv(paste0(
  path_preprocessing_model,
  "surface_ocean/",
  params_local$gobm,
  ".csv"
))

surface_mod <- surface_mod %>% 
  filter(model_ID == "A")

surface_mod <- surface_mod %>%
  select(year,
         lon, lat,
         talk,
         pCO2 = spco2,
         temp,
         sal)

### Observational data (OceanSODA)

surface_obs <- read_csv(paste0(
    path_observations,
    "preprocessing/OceanSODA.csv")
  )

surface_obs <- surface_obs %>% 
  select(lon, lat, year, talk, pCO2, sal, temp)

surface <- bind_rows(
  surface_obs %>% mutate(data_source = "obs"),
  surface_mod %>% mutate(data_source = "mod")
)

rm(surface_mod, surface_obs)



```



## Others

```{r read_other_data}


tref <-
  read_csv(paste(path_version_data,
                 "tref.csv",
                 sep = ""))

GLODAP_adjustments  <-
  read_csv(paste(path_preprocessing,
                 "GLODAPv2.2021_adustments.csv",
                 sep = ""))


```


## Convert to long format

```{r convert_mod_obs_to_long_format}

GLODAP <- GLODAP %>% 
  rename_with(~ gsub("_model", "_mod", .x)) %>% 
  rename_with(.cols = c(temp, sal, gamma, tco2, talk, phosphate,
                        oxygen, aou, nitrate, silicate),
              ~ paste(.x, "obs", sep = "_"))

GLODAP <- GLODAP %>% 
  pivot_longer(
    -c(year:depth), 
    names_to = c(".value", "data_source"), 
    names_sep = "_"
  )


```



## C* input adjustment

```{r read_offset_analysis_output}


expocodes_xover_NP <-
  read_csv(paste(path_preprocessing,
                 "expocodes_xover_NP.csv",
                 sep = ""))

expocodes_xover_IO <-
  read_csv(paste(path_preprocessing,
                 "expocodes_xover_IO.csv",
                 sep = ""))

xover_cruise_decade_all <-
  read_csv(paste(path_preprocessing,
                 "xover_cruise_decade_all.csv",
                 sep = ""))

IO_CRM_xover_1990 <-
  read_csv(paste(path_preprocessing,
                 "IO_CRM_xover_1990.csv",
                 sep = ""))

```


### IO 1990s Knorr

```{r add_expocodes}

GLODAP <-
  left_join(GLODAP,
            GLODAP_adjustments %>%
              distinct(cruise, cruise_expocode))

```


```{r check_existence_IO_1990_data}

exist_IO_1990 <- GLODAP %>%
  filter(between(year, 1989,1999) &
           basin_AIP == "Indian" &
           data_source == "obs") %>% 
  nrow() > 0

```

```{r cstar_input_adjustment_IO, eval=exist_IO_1990}


if (params_local$data_adjustment == "bulk") {
  GLODAP_IO_1990s <- GLODAP %>%
    filter(between(year, 1989, 1999) &
             basin_AIP == "Indian" &
             data_source == "obs") %>%
    mutate(
      cruise_expocode_RV = str_sub(cruise_expocode, 1, 7),
      cruise_expocode_date = str_sub(cruise_expocode, 5, 12)
    )
  
  
  GLODAP_IO_1990s_stats <- GLODAP_IO_1990s %>%
    count(cruise_expocode_RV) %>%
    mutate(n_rel = 100 * n / sum(n)) %>%
    arrange(-n)
  
  GLODAP_IO_1990s_stats %>%
    kbl() %>%
    kable_styling()
  
  GLODAP_IO_1990s_top5 <- GLODAP_IO_1990s_stats %>%
    slice_max(order_by = n, n = 5) %>%
    pull(cruise_expocode_RV)
  
  print(
    map +
      geom_tile(
        data = GLODAP_IO_1990s %>%
          filter(cruise_expocode_RV %in% GLODAP_IO_1990s_top5)  %>%
          distinct(lat, lon, cruise_expocode_RV),
        aes(lon, lat)
      ) +
      xlim(20, 150) +
      ylim(-80, 30) +
      facet_wrap(~ cruise_expocode_RV)
  )
  
  print(
    GLODAP_IO_1990s %>%
      filter(cruise_expocode_RV %in% GLODAP_IO_1990s_top5) %>%
      group_split(cruise_expocode_RV) %>%
      # head(1) %>%
      map(
        ~ map +
          geom_tile(
            data = .x %>%
              distinct(lat, lon, cruise_expocode_date),
            aes(lon, lat, fill = cruise_expocode_date)
          ) +
          scale_fill_brewer(palette = "Set1",
                            name = "cruise start date") +
          labs(title = paste0(
            "expocodes: ",
            unique(.x$cruise_expocode_RV),
            "XXXXX"
          )) +
          xlim(20, 150) +
          ylim(-80, 30)
      )
  )
  
  
  rm(GLODAP_IO_1990s,
     GLODAP_IO_1990s_stats,
     GLODAP_IO_1990s_top5)
  
  GLODAP_adj <- GLODAP %>%
    filter(str_detect(cruise_expocode, "316N199") &
             basin_AIP == "Indian" &
             data_source == "obs")
  
  GLODAP_unadj <- GLODAP %>%
    filter(!(
      str_detect(cruise_expocode, "316N199") &
        basin_AIP == "Indian" &
        data_source == "obs"
    ))
  
  nrow(GLODAP_adj) + nrow(GLODAP_unadj) == nrow(GLODAP)
  
  print(map +
          geom_tile(
            data = GLODAP_adj %>%
              distinct(lat, lon, year),
            aes(lon, lat, fill = as.factor(year))
          ))
  
  print(
    map +
      geom_tile(
        data = GLODAP_adj %>%
          distinct(lat, lon, cruise_expocode),
        aes(lon, lat, fill = cruise_expocode)
      ) +
      scale_fill_brewer(palette = "Set1")
  )
  
  
  GLODAP_adj <- GLODAP_adj %>%
    mutate(
      tco2 = tco2 + params_local$tco2_corr_316N199,
      talk = talk + params_local$talk_corr_316N199,
      phosphate = phosphate * params_local$phosphate_corr_316N199,
    )
  
  GLODAP <- bind_rows(GLODAP_adj,
                      GLODAP_unadj)
  
  
  rm(GLODAP_adj,
     GLODAP_unadj)
  
}



# apply cruise-wise correction to NP 2010 data
if (params_local$data_adjustment == "cruise") {
  
  print(
  IO_CRM_xover_1990 %>% 
    ggplot(aes(offset_mean)) +
    geom_histogram() +
    facet_grid(type ~ parameter)
  )
  
  IO_CRM_xover_1990 <- IO_CRM_xover_1990 %>%
    filter(type == "CRM") %>%
    select(cruise_expocode, parameter,
           corr_IO_1900 = offset_mean) %>%
    pivot_wider(names_from = parameter,
                values_from = corr_IO_1900,
                names_glue = "{parameter}_{.value}")
  
  
  GLODAP <- left_join(GLODAP,
                      IO_CRM_xover_1990)
  
  print(
  GLODAP %>% 
    filter(!is.na(talk_corr_IO_1900)) %>% 
    ggplot(aes(date, talk_corr_IO_1900)) +
    geom_point()
  )
  
  print(
  GLODAP %>% 
    filter(!is.na(tco2_corr_IO_1900)) %>% 
    ggplot(aes(date, tco2_corr_IO_1900)) +
    geom_point()
  )
  
  
  GLODAP <- GLODAP %>%
    mutate(
      talk = if_else(!is.na(talk_corr_IO_1900) &
                       data_source == "obs",
                     talk - talk_corr_IO_1900,
                     talk),
      tco2 = if_else(!is.na(tco2_corr_IO_1900) &
                       data_source == "obs",
                     tco2 - tco2_corr_IO_1900,
                     tco2)
    )
  
  GLODAP <- GLODAP %>%
    select(-ends_with("corr_IO_1900"))
  
}


```


### Calculated talk

```{r correct_calculated_talk}

GLODAP <- GLODAP %>%
  mutate(
    talk = if_else(
      cruise_expocode %in% params_local$cruises_talk_calc &
        data_source == "obs",
      talk + params_local$talk_calc_corr,
      talk
    )
  )


```

### North Pacific 2010s

```{r correct_North_Pacific_talk_tco2_obs}

expocodes_xover_NP <- expocodes_xover_NP %>% 
  pull(cruise_expocode)


# apply bulk correction to NP 2010 data
if (params_local$data_adjustment == "bulk") {
  GLODAP <- GLODAP %>%
    mutate(
      phosphate = if_else(
        cruise_expocode %in% expocodes_xover_NP &
          data_source == "obs" &
          era == "2010-2020",
        phosphate * params_local$phosphate_corr_NP_2010,
        phosphate
      ),
      talk = if_else(
        cruise_expocode %in% expocodes_xover_NP &
          data_source == "obs" &
          era == "2010-2020",
        talk + params_local$talk_corr_NP_2010,
        talk
      ),
      tco2 = if_else(
        cruise_expocode %in% expocodes_xover_NP &
          data_source == "obs" &
          era == "2010-2020",
        tco2 + params_local$tco2_corr_NP_2010,
        tco2
      )
    )
}


# apply cruise-wise correction to NP 2010 data
if (params_local$data_adjustment == "cruise") {
  
  xover_cruise_decade_NP_2010 <- xover_cruise_decade_all %>% 
    filter(decade_A == "2010-2020",
           decade == "2000-2009",
           basin == "N. Pacific",
           cruise_A %in% expocodes_xover_NP,
           parameter_coverage == "full",
           parameter %in% c("cstar_tco2", "cstar_talk", "phosphate")) %>% 
    mutate(parameter = str_remove(parameter, "cstar_"))
  
  xover_cruise_decade_NP_2010 <- xover_cruise_decade_NP_2010 %>% 
    select(cruise_expocode = cruise_A,
           parameter,
           corr_NP_2010 = offset_adj_mean_weighted) %>% 
    pivot_wider(names_from = parameter,
                values_from = corr_NP_2010,
                names_glue = "{parameter}_{.value}")
  
  GLODAP <- left_join(GLODAP,
                      xover_cruise_decade_NP_2010)
  
  GLODAP <- GLODAP %>%
    mutate(
      phosphate = if_else(
        cruise_expocode %in% expocodes_xover_NP &
          data_source == "obs" &
          era == "2010-2020" &
          !is.na(phosphate_corr_NP_2010),
        phosphate / phosphate_corr_NP_2010,
        phosphate
      ),
      talk = if_else(
        cruise_expocode %in% expocodes_xover_NP &
          data_source == "obs" &
          era == "2010-2020" & 
          !is.na(talk_corr_NP_2010),
        talk + talk_corr_NP_2010*2,
        talk
      ),
      tco2 = if_else(
        cruise_expocode %in% expocodes_xover_NP &
          data_source == "obs" &
          era == "2010-2020" & 
          !is.na(tco2_corr_NP_2010),
        tco2 - tco2_corr_NP_2010,
        tco2
      )
    )
  
  GLODAP <- GLODAP %>% 
    select(-ends_with("corr_NP_2010"))
  
}

rm(expocodes_xover_NP)

```



# PO~4~* calculation 

The predictor PO~4~* was be calculated according to Clement and Gruber (2018), ie based on oxygen. Please note that an erroneous equations for PO4* calculation is given in the supplement of Gruber et al (2019), based on nitrate.  

Here we use following equation, if PO~4~* is used as predictor:

```{r calculate_phosphate_star}

print(b_phosphate_star)

if ("phosphate_star" %in% params_local$MLR_predictors) {
GLODAP <- GLODAP %>% 
  mutate(phosphate_star = b_phosphate_star(phosphate, oxygen))
}

```

Note, currently we decided to avoid using PO~4~* as predictor, because it is equivalent to using PO~4~ and O~2~.

# C*

C* serves as a conservative tracer of anthropogenic CO~2~ uptake. It is derived from measured DIC by removing the impact of  

- organic matter formation and respiration
- calcification and calcium carbonate dissolution

Contributions of those processes are estimated from phosphate and alkalinity concentrations.

## Stoichiometric ratios

The stoichiometric nutrient ratios for the production and mineralization of organic matter were set to:

- C/P: `r params_local$rCP`
- N/P: `r params_local$rNP`

## Calculation

C* can optionally be calculated based on phosphate or nitrate. 

```{r calculate_cstar}

GLODAP <- GLODAP %>%
  mutate(
    cstar_nitrate = b_cstar_nitrate(tco2, nitrate, talk),
    cstar_phosphate = b_cstar_phosphate(tco2, phosphate, talk)
  )


p_prop_prop(df = GLODAP,
            var1 = "cstar_phosphate",
            var2 = "cstar_nitrate") +
  facet_grid(data_source ~ basin_AIP)

GLODAP %>% 
  ggplot(aes(aou, cstar_nitrate - cstar_phosphate)) +
  geom_bin2d() +
  scale_fill_viridis_c() +
  facet_grid(data_source ~ basin_AIP)

GLODAP %>% 
  ggplot(aes(nitrate, cstar_nitrate - cstar_phosphate)) +
  geom_bin2d() +
  scale_fill_viridis_c() +
  facet_grid(data_source ~ basin_AIP)

```

C* was actually calculated as: 

```{r cstar_selection}

if (params_local$cstar_nutrient == "phosphate") {
  print(b_cstar_phosphate)
  
  GLODAP <- GLODAP %>%
    mutate(cstar_phosphate = b_cstar_phosphate(tco2, phosphate, talk)) %>%
    rename(cstar = cstar_phosphate) %>%
    select(-cstar_nitrate)
}

if (params_local$cstar_nutrient == "nitrate") {
  print(b_cstar_nitrate)
  
  GLODAP <- GLODAP %>%
    mutate(cstar_nitrate = b_cstar_nitrate(tco2, nitrate, talk)) %>%
    rename(cstar = cstar_nitrate) %>%
    select(-cstar_phosphate)
}

```



## Reference year adjustment

To adjust observation-based C* values to the reference year of each observation period, we assume a transient steady state change of cant between the time of sampling the reference year. The adjustment requires an approximation of the total cant concentration at the reference year. We approximate this concentration for tref(1) by adding the delta cant signal estimated by Gruber et al (2019) to the "base line" total cant concentration determined for 1994 by Sabine et al (2004):  

Cant(tref) = S04 + (tref-1994)/13 * G19

This way, we use exactly S04+G19 for tref(1)=2007. For all other tref(1) we scale Cant with the observed anomalous change over the 1994-2007 period, rather than assuming a transient steady state. However, one assumes a linear behaviour of the anomalous change over time, which might be wrong in particular for the years past 2007.

Therefore, we estimate the total Cant at tref(2) by scaling total cant at tref(1) with alpha, according to Gruber et al. (2019).

For the model data, we perform an analogous adjustment based on the total Cant estimate for 1994 (corresponding to Sabine 2004), and the delta Cant estimate for 1994 - 2007 (corresponding to Gruber 2019).


### Join Cant fields

Join observation-based Cant fields of G19 and S04

```{r join_cant_estimates_observations, fig.asp=0.5}

G19_cant_3d <- G19_cant_3d %>% 
  select(lon, lat, depth, cant_pos_G19 = dcant_pos)

S04_cant_3d <- S04_cant_3d %>% 
  select(lon, lat, depth, cant_pos_S04 = tcant_pos)

# check regional coverage of both data sets
cant_3d_coverage <- full_join(
  S04_cant_3d %>% distinct(lat, lon),
  G19_cant_3d %>% distinct(lat, lon)
)

cant_3d_coverage <- full_join(
  cant_3d_coverage,
  G19_cant_3d %>% distinct(lat, lon) %>% mutate(G19 = "y")
)

cant_3d_coverage <- full_join(
  cant_3d_coverage,
  S04_cant_3d %>% distinct(lat, lon) %>% mutate(S04 = "y")
)

cant_3d_coverage <- cant_3d_coverage %>% 
  mutate(coverage = case_when(
    G19 == "y" & S04 == "y" ~ "both",
    is.na(G19) & S04 == "y" ~ "S04",
    G19 == "y" & is.na(S04) ~ "G19"))

map +
  geom_raster(data = cant_3d_coverage,
              aes(lon, lat, fill = coverage)) +
  geom_raster(data = GLODAP %>% distinct(lat, lon),
              aes(lon, lat)) +
  scale_fill_brewer(palette = "Dark2")

rm(cant_3d_coverage)


# join data sets
cant_3d <- full_join(S04_cant_3d, G19_cant_3d)

cant_3d <- cant_3d %>%
  mutate(cant_pos_S04 = replace_na(cant_pos_S04, 0),
         cant_pos_G19 = replace_na(cant_pos_G19, 0))


```

Join model Cant fields of 1994 and 2007

```{r join_cant_estimates_model, fig.asp=0.5}

# define positive cant
m94_cant_3d <- m94_cant_3d %>% 
  mutate(cant_pos = if_else(tcant <= 0, 0, tcant)) %>% 
  select(lon, lat, depth, cant_pos_S04 = cant_pos)

m07_cant_3d <- m07_cant_3d %>% 
  mutate(cant_pos = if_else(tcant <= 0, 0, tcant)) %>% 
  select(lon, lat, depth, cant_pos_m07 = cant_pos)

# join data sets
mod_cant_3d <- full_join(
  m94_cant_3d,
  m07_cant_3d
)

# calculate the delta cant signal, i.e. the analogue to G19
mod_cant_3d <- mod_cant_3d %>% 
  mutate(cant_pos_G19 = cant_pos_m07 - cant_pos_S04,
         cant_pos_G19 = if_else(cant_pos_G19 <= 0, 
                                0, cant_pos_G19)) %>% 
  select(-cant_pos_m07)

rm(m07_cant_3d,
   m94_cant_3d)

```

Join mod and obs Cant

```{r join_obs_mod_cant}

cant_3d <- bind_rows(
  mod_cant_3d %>% mutate(data_source = "mod"),
  cant_3d %>% mutate(data_source = "obs")
)

cant_3d <- inner_join(cant_3d, basinmask)

```

### tcant at tref1

Calculate total Cant at tref1 by adding G19 to S04, linearly scaled for the time since 1994. Note: For tref1 close to 1994, this should be a marginal change compared to taking SO4 directly.

```{r calculate_cant_tref1}

tcant_3d <- cant_3d %>%
  mutate(tcant_pos = cant_pos_S04 +
           ((min(tref$median_year) - 1994) / 13 * cant_pos_G19))

rm(cant_3d)

# join cant with tref
tcant_3d <- expand_grid(tcant_3d, tref)


# linear scaling of Gruber 2019
# calculate cant fields for all tref
tcant_3d_t1 <- tcant_3d %>%
  filter(median_year == min(tref$median_year))


```


### Revelle factor ratio

```{r calc_rev_fac_ratio, fig.asp=0.5}

# determine mean year for both eras
tref_mean <- c(sort(tref$median_year)[1]-50 , round(mean(tref$median_year)))

# extract surface ocean data for second mean year
surface <- surface %>% 
  filter(year == round(mean(tref$median_year)))

# extract atm pCO2 level for time before first era
delta_pCO2_hist <- co2_atm_reccap2 %>% 
  filter(year %in% tref_mean) %>% 
  arrange(year) %>% 
  mutate(delta_pCO2_hist = pCO2 - lag(pCO2)) %>% 
  drop_na() %>% 
  pull(delta_pCO2_hist)

# derive historic surface pCO2 field
surface_hist <- surface %>% 
  mutate(pCO2 = pCO2 - delta_pCO2_hist,
         year = tref_mean[1])

surface <- bind_rows(
  surface,
  surface_hist
)

map +
  geom_raster(data = surface,
              aes(lon, lat, fill=pCO2)) +
  scale_fill_viridis_c() +
  facet_grid(data_source ~ year)

# calculate surface revelle factor distribution
surface <- surface %>%
  drop_na() %>% 
  mutate(
    rev_fac = buffer(
      flag = 24,
      var1 = pCO2,
      var2 = talk * 1e-6,
      S = sal,
      T = temp,
      P = 0,
      k1k2 = "l"
    )$BetaD
  )

map +
  geom_raster(data = surface,
              aes(lon, lat, fill=rev_fac)) +
  scale_fill_viridis_c() +
  facet_grid(data_source ~ year)

# calculate revelle factor ratios
surface <- surface %>% 
  arrange(year) %>% 
  group_by(lon, lat, data_source) %>% 
  mutate(rev_fac_ratio = lag(rev_fac) / rev_fac) %>% 
  ungroup() %>% 
  drop_na()

map +
  geom_raster(data = surface,
              aes(lon, lat, fill=rev_fac_ratio)) +
  scale_fill_viridis_c() +
  facet_grid(data_source ~ .)

# area weighted mean changes in revelle factor
rev_fac_ratio <- surface %>% 
  mutate(area = earth_surf(lat = lat),
         rev_fac_ratio_scaled = area * rev_fac_ratio) %>% 
  group_by(data_source) %>% 
  summarise(rev_fac_ratio = sum(rev_fac_ratio_scaled) / sum(area)) %>% 
  ungroup()

rm(surface, surface_hist, delta_pCO2_hist, tref_mean)

```

### Alpha

```{r calc_alpha}

# extract atm pCO2 at reference years
co2_atm_tref <- right_join(co2_atm, tref %>% rename(year = median_year)) %>% 
  select(-year) %>% 
  rename(pCO2_tref = pCO2)

# calculate change in atm pCO2
co2_atm_tref <- co2_atm_tref %>% 
  mutate(delta_pCO2_atm = pCO2_tref - 
           lag(pCO2_tref, default = params_local$preind_atm_pCO2))

# derive change in atm-sea disequilibrium pCO2
delta_pco2_annual <- right_join(delta_pco2_annual,
                                GLODAP %>%
                                  distinct(year, era)) %>%
  drop_na()

# plot disequilibrium time series
delta_pco2_annual %>%
  ggplot(aes(year, delta_pco2_glob)) +
  geom_path(aes(linetype=data_source)) +
  geom_point(aes(col = era, shape=data_source)) +
  scale_color_brewer(palette = "Set1")

# create data frame with preindustrial disequilibrium for model and observations
disequi_pCO2_pi <- bind_cols(
  era = rep(paste0("1750-",tref$median_year[1]),2),
  data_source = c("mod", "obs"),
  mean_delta_pCO2 = c(0,3)
)

disequi_pCO2_tref <- delta_pco2_annual %>% 
  group_by(era, data_source) %>% 
  summarise(mean_delta_pCO2 = mean(delta_pco2_glob)) %>% 
  ungroup()

disequi_pCO2_tref <- bind_rows(
  disequi_pCO2_pi,
  disequi_pCO2_tref
)

rm(disequi_pCO2_pi)

disequi_pCO2_tref <- disequi_pCO2_tref %>% 
  arrange(era) %>% 
  group_by(data_source) %>% 
  mutate(disequi_pCO2_change = mean_delta_pCO2 - lag(mean_delta_pCO2)) %>% 
  ungroup() %>% 
  drop_na()

# calculate xeta ratio
disequi_pCO2_change <- full_join(
  disequi_pCO2_tref,
  co2_atm_tref)

disequi_pCO2_change <- disequi_pCO2_change %>% 
  mutate(xeta = (delta_pCO2_atm - disequi_pCO2_change) / delta_pCO2_atm) %>% 
  arrange(era) %>% 
  group_by(data_source) %>% 
  mutate(xeta_ratio = xeta / lag(xeta),
         delta_pCO2_atm_ratio = delta_pCO2_atm / lag(delta_pCO2_atm)) %>% 
  ungroup()

disequi_pCO2_change <- full_join(
  disequi_pCO2_change,
  rev_fac_ratio
)
rm(rev_fac_ratio)

# determine alpha scaling factor
disequi_pCO2_change <- disequi_pCO2_change %>% 
  mutate(alpha = delta_pCO2_atm_ratio * xeta_ratio * rev_fac_ratio) %>% 
  select(-c(pCO2_tref, delta_pCO2_atm_ratio))

disequi_pCO2_change %>% 
  kbl() %>% 
  kable_styling()

alpha_df <- disequi_pCO2_change %>% 
  select(data_source, alpha) %>% 
  drop_na()


```


### tcant at tref2

Calculate total Cant at tref2 by scaling the tref1 estimate with alpha according to Gruber et al 2019.


```{r calc_cant_tref1}

tcant_3d_t2 <- full_join(tcant_3d %>% filter(median_year == max(tref$median_year)),
                        alpha_df) %>% 
  mutate(tcant_pos = tcant_pos * (1 + alpha)) %>% 
  select(-alpha)

tcant_3d <- bind_rows(tcant_3d_t1, tcant_3d_t2)
rm(tcant_3d_t1, tcant_3d_t2)

# remove columns
tcant_3d <- tcant_3d %>% 
  select(data_source, basin_AIP, lon, lat, depth, era, tcant_pos)

tcant_3d %>% 
  ggplot(aes(tcant_pos, depth)) +
  geom_bin2d() +
  facet_grid(era ~ data_source) +
  scale_fill_viridis_c() +
  scale_y_reverse()

tcant_zonal <- tcant_3d %>%
  group_by(data_source, era) %>%
  nest() %>%
  mutate(section = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(section)

tcant_3d <- tcant_3d %>% 
  select(-basin_AIP)

```


### Combine GLODAP + tcant

```{r merge_cstar_cant, fig.asp=0.8}

# observations grid per era
GLODAP_obs_grid_era <- GLODAP %>% 
  distinct(lat, lon, era, data_source)

# cant data at observations grid
tcant_3d_obs <- left_join(
  GLODAP_obs_grid_era,
  tcant_3d)

tcant_3d_obs <- tcant_3d_obs %>%
  mutate(tcant_pos = replace_na(tcant_pos, 0),
         depth = replace_na(depth, 0))

# calculate number of cant data points per grid cell
tcant_3d_obs <- tcant_3d_obs %>%
  group_by(lon, lat, era, data_source) %>% 
  mutate(n = n(),
         n_group = if_else(n > 1, "n > 1", "n <= 1")) %>% 
  ungroup()

# GLODAP observations with only one Cant value
map +
  geom_raster(data = tcant_3d_obs,
             aes(lon, lat, fill = n_group)) +
  scale_fill_brewer(palette = "Set1", name="n") +
  facet_grid(data_source ~ era) +
  labs(title = "Number of Cant depth levels",
       subtitle = "available per latxlon grid cell")


tcant_3d_obs <- tcant_3d_obs %>% 
  select(-n_group)

rm(GLODAP_obs_grid_era)

GLODAP_tcant_obs <- full_join(GLODAP, tcant_3d_obs)

rm(GLODAP, tcant_3d_obs)

# fill number of cant data points per grid cell to all observations
GLODAP_tcant_obs <- GLODAP_tcant_obs %>%
  group_by(lon, lat, era, data_source) %>% 
  fill(n, .direction = "updown") %>% 
  ungroup()

```

The mapped Cant product was merged with GLODAP observation by:

- using an identical 1x1째 horizontal grid
- linear interpolation of C~ant~ from standard to sampling depth

```{r cant_interpolation_to_observations}

# interpolate cant to observation depth
GLODAP_tcant_obs_int <- GLODAP_tcant_obs %>%
  filter(n > 1) %>% 
  group_by(lat, lon, era, data_source) %>%
  arrange(depth) %>%
  mutate(tcant_pos_int = approxfun(depth, tcant_pos, rule = 2)(depth)) %>%
  ungroup()

# set cant for observation depth if only one cant available
GLODAP_tcant_obs_set <- GLODAP_tcant_obs %>%
  filter(n == 1) %>%
  group_by(lat, lon, era, data_source) %>%
  mutate(tcant_pos_int = mean(tcant_pos, na.rm = TRUE)) %>%
  ungroup()

# bin data sets with interpolated and set cant
GLODAP_tcant_obs <- bind_rows(GLODAP_tcant_obs_int, GLODAP_tcant_obs_set)
rm(GLODAP_tcant_obs_int, GLODAP_tcant_obs_set)


# remove cant data at grid cells without observations
GLODAP <- GLODAP_tcant_obs %>%
  filter(!is.na(cstar)) %>%
  mutate(tcant_pos = tcant_pos_int) %>%
  select(-tcant_pos_int, n)

rm(GLODAP_tcant_obs)

```


### Merge GLODAP + atm. pCO~2~

GLODAP observations were merged with mean annual atmospheric pCO~2~ levels by year.

```{r merge_cstar_pCO2}

GLODAP <- left_join(GLODAP, co2_atm)

```

### Calculation

```{r adjust_reference_year}

# assign reference year
GLODAP <- full_join(GLODAP, tref)

# extract atm pCO2 at reference year
co2_atm_tref <- right_join(co2_atm, tref %>% rename(year = median_year)) %>% 
  select(-year) %>% 
  rename(pCO2_tref = pCO2)

# merge atm pCO2 at tref with GLODAP
GLODAP <- full_join(GLODAP, co2_atm_tref)
rm(co2_atm)


# calculate cstar for reference year
GLODAP <- GLODAP %>%
  mutate(
    cstar_tref_delta =
      ((pCO2 - pCO2_tref) / (pCO2_tref - params_local$preind_atm_pCO2)) * tcant_pos,
    cstar_tref = cstar - cstar_tref_delta,
    cstar_tref_delta = - cstar_tref_delta,
  )

```


## Control plots

```{r cstar_reference_year_adjustment_histogram}

GLODAP %>% 
  ggplot(aes(cstar_tref_delta)) +
  geom_histogram(binwidth = 1) +
  labs(title = "Histogramm with binwidth = 1") +
  facet_wrap(~ data_source)

```

```{r cstar_reference_year_adjustment_vs_time_cant}

GLODAP %>% 
  sample_n(1e4) %>% 
  ggplot(aes(year, cstar_tref_delta, col = tcant_pos)) +
  geom_point() +
  scale_color_viridis_c() +
  labs(title = "Time series of random subsample 1e4") +
  facet_wrap(~ data_source)

```

```{r cstar_reference_year_adjustment_vs_time_counts}

GLODAP %>% 
  ggplot(aes(year, cstar_tref_delta)) +
  geom_bin2d(binwidth = 1) +
  scale_fill_viridis_c(trans = "log10") +
  labs(title = "Heatmap with binwidth = 1") +
  facet_wrap(~ data_source)

```

# Isoneutral slabs

```{r density_histograms}

GLODAP %>% 
  ggplot(aes(gamma)) +
  geom_histogram() +
  facet_grid(basin_AIP~data_source)

```


```{r density_profiles}

GLODAP %>% 
  ggplot(aes(gamma, depth)) +
  geom_bin2d() +
  scale_y_reverse() +
  scale_fill_viridis_c() +
  facet_grid(basin_AIP~data_source)

```

```{r mean_density_profiles}

gamma_profiles <- GLODAP %>%
  mutate(depth_int = as.numeric(as.character(cut(
    depth, seq(0, 2e4, 50),
    seq(25, 2e4, 50)
  )))) %>%
  select(data_source, basin_AIP, depth_int, gamma) %>% 
  group_by(data_source, basin_AIP, depth_int) %>% 
  summarise(gamma_mean = mean(gamma, na.rm = TRUE),
            gamma_sd = sd(gamma, na.rm = TRUE)) %>% 
  ungroup()

gamma_profiles_bias <- gamma_profiles %>% 
  select(-gamma_sd) %>% 
  pivot_wider(names_from = data_source,
              values_from = gamma_mean) %>% 
  mutate(gamma_bias = mod - obs)

gamma_profiles %>%
  ggplot() +
  geom_vline(xintercept = params_local$slabs_Ind_Pac,
             col = "grey50") +
  geom_ribbon(
    aes(
      xmin = gamma_mean - gamma_sd,
      xmax = gamma_mean + gamma_sd,
      y = depth_int,
      fill = data_source
    ),
    alpha = 0.3
  ) +
  geom_path(aes(gamma_mean, depth_int, col = data_source)) +
  geom_point(aes(gamma_mean, depth_int, col = data_source)) +
  scale_y_reverse() +
  facet_grid(. ~ basin_AIP)

gamma_profiles_bias %>% 
  ggplot(aes(gamma_bias, depth_int)) +
  geom_point() +
  scale_y_reverse() +
  facet_grid(.~basin_AIP)

mean_gamma_offset_Indo_Pac <- gamma_profiles_bias %>% 
  filter(basin_AIP %in% c("Indian", "Pacific")) %>%
  summarise(gamma_offset = mean(gamma_bias,
                                na.rm = TRUE)) %>% 
  pull()

mean_gamma_offset_Atl <- gamma_profiles_bias %>% 
  filter(basin_AIP %in% c("Atlantic")) %>%
  summarise(gamma_offset = mean(gamma_bias,
                                na.rm = TRUE)) %>% 
  pull()


GLODAP <- GLODAP %>%
  mutate(
    gamma = if_else(
      basin_AIP %in% c("Indian", "Pacific") &
        data_source == "mod",
      gamma - mean_gamma_offset_Indo_Pac,
      gamma
    ),
    gamma = if_else(
      basin_AIP %in% c("Atlantic") &
        data_source == "mod",
      gamma - mean_gamma_offset_Atl,
      gamma
    )
  )


```

```{r density_cuts, eval=FALSE}

GLODAP <- GLODAP %>% 
  group_by(basin_AIP) %>% 
  mutate(gamma_slab = cut_number(gamma, n = 10)) %>% 
  ungroup()

GLODAP_slab <- GLODAP %>% 
  count(gamma_slab, basin_AIP, era)


GLODAP_slab %>% 
  ggplot(aes(gamma_slab, n, fill=era)) +
  geom_col() +
  facet_grid(.~basin_AIP, scales = "free_x") +
  theme(axis.text.x = element_text(angle = 90))

```


The following boundaries for isoneutral slabs were defined:

- Atlantic: `r params_local$slabs_Atl`
- Indo-Pacific: `r params_local$slabs_Ind_Pac`

Continuous neutral densities (gamma) values from GLODAP are grouped into isoneutral slabs.

```{r cut_isoneutral_slabs}

GLODAP <- m_cut_gamma(GLODAP, "gamma")

```


```{r test_isoneutral_density_calculation, eval=FALSE, hide=TRUE}

# this section was only used to calculate gamma locally, and compare it to the value provided in GLODAP data set

GLODAP_cruise <- GLODAP %>% 
  filter(cruise %in% params_global$cruises_meridional)

library(oce)
library(gsw)
# calculate pressure from depth

GLODAP_cruise <- GLODAP_cruise %>% 
  mutate(CTDPRS = gsw_p_from_z(-depth,
                               lat))

GLODAP_cruise <- GLODAP_cruise %>% 
  mutate(THETA = swTheta(salinity = sal,
                         temperature = temp,
                         pressure = CTDPRS,
                         referencePressure = 0,
                         longitude = lon-180,
                         latitude = lat))

GLODAP_cruise <- GLODAP_cruise %>% 
  rename(LATITUDE = lat,
         LONGITUDE = lon,
         SALNTY = sal,
         gamma_provided = gamma)

library(reticulate)
data_source_python(here::here("code/python_scripts",
                         "Gamma_GLODAP_python.py"))

GLODAP_cruise <- calculate_gamma(GLODAP_cruise)

GLODAP_cruise <- GLODAP_cruise %>% 
  mutate(gamma_delta = gamma_provided - GAMMA)

lat_section <- 
GLODAP_cruise %>%
  ggplot(aes(LATITUDE, CTDPRS)) +
  scale_y_reverse() +
  theme(legend.position = "bottom")

lat_section +
  stat_summary_2d(aes(z = gamma_delta)) +
  scale_color_viridis_c()

GLODAP_cruise %>% 
  ggplot(aes(gamma_delta))+
  geom_histogram()

rm(lat_section, GLODAP_cruise, cruises_meridional)

```

# Reoccupation filter

Reoccupation filter was applied: `r params_local$rarefication == "reoccupation"`

```{r filter_reoccupied_observations, fig.asp=2}

GLODAP_grid <- GLODAP %>% 
  distinct(lon, lat, gamma_slab, era)

GLODAP_grid <- GLODAP_grid %>% 
  group_by(lat, lon, gamma_slab) %>% 
  mutate(n = n()) %>% 
  ungroup() %>% 
  mutate(era_label = if_else(n==1, era, "both"))

map+
  geom_raster(data = GLODAP_grid,
              aes(lon, lat, fill = era_label)) +
  facet_wrap(~ gamma_slab, ncol = 2) +
  scale_fill_brewer(palette = "Set1", direction = -1)

GLODAP_grid <- GLODAP_grid %>% 
  filter(era_label == "both") %>% 
  distinct(lat, lon, gamma_slab)

if (params_local$rarefication == "reoccupation") {

  GLODAP <- left_join(GLODAP_grid, GLODAP)
  
}

rm(GLODAP_grid)

```

# Indian Ocean 1990s

## C* adjustment

```{r cstar_adjustment_IO, eval=exist_IO_1990}

GLODAP_adj <- GLODAP %>%
  filter(str_detect(cruise_expocode, "316N199") &
           basin_AIP == "Indian" &
           data_source == "obs")

GLODAP_unadj <- GLODAP %>%
  filter(!(str_detect(cruise_expocode, "316N199") &
           basin_AIP == "Indian" &
           data_source == "obs"))

GLODAP_adj <- GLODAP_adj %>%
  mutate(
    cstar_tref = cstar_tref + params_local$cstar_corr_316N199,
    ) 

GLODAP <- bind_rows(
  GLODAP_adj,
  GLODAP_unadj
)


rm(GLODAP_adj,
   GLODAP_unadj)



```

```{r remove_expocodes}

GLODAP <- GLODAP %>%
  select(-cruise_expocode)


```



# C* distributions

## Profiles

```{r cstar_profiles, fig.asp=3, eval=FALSE}

GLODAP_profiles_IO_sub <- GLODAP %>% 
  filter(depth > 1000,
         data_source == "obs") %>% 
  count(cruise, basin_AIP, era) %>% 
  arrange(-n) %>%
  group_by(basin_AIP, era) %>% 
  slice_max(n, n = 10) %>% 
  ungroup() %>% 
  pull(cruise)

GLODAP_profiles <- GLODAP %>%
  filter(data_source == "obs",
         depth > 1000) %>%
  filter(cruise %in% GLODAP_profiles_IO_sub)

rm(GLODAP_profiles_IO_sub)

GLODAP_profiles %>%
  arrange(depth, station) %>%
  ggplot(aes(cstar_tref, depth,
             group = interaction(station),
             col = basin_AIP)) +
  scale_color_brewer(palette = "Dark2") +
  geom_path() +
  scale_y_reverse() +
  facet_wrap(~ interaction(era, cruise), ncol = 3)

map +
  geom_tile(data = GLODAP_profiles %>%
              distinct(lat, lon, era, cruise),
            aes(lon, lat)) +
  facet_wrap( ~ interaction(era, cruise),
              ncol = 3)

rm(GLODAP_profiles)

```

```{r cstar_station_stats, eval=FALSE}

cstar_station_stats <- GLODAP %>% 
  filter(depth >= 2000,
         depth <= 5000) %>% 
  group_by(cruise, station, data_source) %>%
  mutate(cstar_offset = cstar_tref - mean(cstar_tref, na.rm = TRUE)) %>% 
  ungroup() %>% 
  group_by(cruise, station, data_source, era, basin_AIP) %>% 
  summarise(cstar_sd = sd(cstar_offset, na.rm = TRUE),
            cstar_mean = mean(cstar_tref, na.rm = TRUE),
            n = n()) %>% 
  ungroup()

cstar_station_stats %>%
  ggplot() +
  geom_histogram(aes(n, fill = era),
                 position = "dodge") +
  facet_grid(basin_AIP ~ data_source)

cstar_station_stats <- cstar_station_stats %>% 
  filter(n >= 3) %>% 
  group_by(basin_AIP, era) %>% 
  mutate(cstar_sd_rank = rank(cstar_sd)) %>% 
  ungroup()

  
cstar_station_stats %>% 
  ggplot() +
  geom_histogram(aes(cstar_sd, fill=era),
                 position = "dodge") +
  facet_grid(basin_AIP ~ data_source)

  
cstar_station_stats %>% 
  ggplot() +
  geom_histogram(aes(cstar_mean, fill=era),
                 position = "dodge") +
  facet_grid(basin_AIP ~ data_source)

cstar_station_stats %>% 
  ggplot() +
  geom_density(aes(cstar_mean,
                   fill=era,
                   col=era),
               alpha = 0.2) +
  facet_grid(basin_AIP ~ data_source,
             scales = "free_y")


cstar_station_stats %>%  
  ggplot() +
  geom_point(aes(cstar_sd_rank, cstar_sd, col=era)) +
  facet_grid(basin_AIP ~ data_source)

cstar_station_stats %>%  
  filter(data_source == "obs") %>% 
  ggplot(aes(cstar_sd, cstar_mean)) +
  geom_bin_2d() +
  facet_grid(basin_AIP ~ era,
             scales = "free_y") +
  scale_fill_viridis_c() +
  geom_smooth(col = "red")

map +
  geom_raster(data = left_join(cstar_station_stats,
                               GLODAP %>%
                                 distinct(cruise, station, lon, lat)),
              aes(lon, lat, fill = cut(cstar_sd, c(0, 3, 6, Inf)))) +
  facet_grid(data_source ~ era) +
  scale_fill_viridis_d(direction = -1,
                       name = "cstar SD",
                       option = "magma") +
  theme(legend.position = "bottom")


```

### Apply scatter filter

```{r deep_profile_cstar_scatter_filter, eval=FALSE}

cruise_SD_out <- cstar_station_stats %>% 
  filter(data_source == "obs",
         cstar_sd >= params_local$cstar_deep_sd) %>% 
  distinct(cruise, station, era, basin_AIP) %>% 
  mutate(flag_SD = "removed")

grid_pre <- GLODAP %>% 
  distinct(lon, lat, era)

GLODAP <-
  full_join(GLODAP,
            cruise_SD_out) %>%
  filter(is.na(flag_SD)) %>%
  select(-flag_SD)

grid_post <- GLODAP %>% 
  distinct(lon, lat, era)

map +
  geom_tile(data = grid_pre,
            aes(lon, lat, fill = "pre")) +
  geom_tile(data = grid_post,
            aes(lon, lat, fill = "post")) +
  scale_fill_brewer(palette = "Set1") +
  facet_grid(era ~ .)


rm(cstar_station_stats, grid_post, grid_pre)

```

## Slab distribution

### Absolute

```{r cstar_slab_distribution_absolute, fig.asp=0.8}

# calculate cstar contributions from components
GLODAP <- GLODAP %>%
  mutate(
    cstar_tco2 = tco2,
    cstar_talk = -0.5 * talk,
    cstar_tco2_talk = cstar_tco2 + cstar_talk,
    cstar_phosphate = -params_local$rCP * phosphate - params_local$rNP *
      0.5 * phosphate,
    cstar_tco2_talk_phosphate = cstar_tco2_talk + cstar_phosphate,
    cstar_nitrate = -params_local$rCP / params_local$rNP * nitrate - 0.5 * nitrate
  )

GLODAP_cstar <- GLODAP %>%
  filter(data_source == "obs")

cstar_grid <- m_grid_horizontal_coarse(GLODAP_cstar)

cstar_grid <- cstar_grid %>%
  group_by(lat_grid, lon_grid, gamma_slab, era, data_source, basin_AIP) %>%
  summarise(across(starts_with("cstar_"), ~ mean(.x, na.rm = TRUE))) %>%
  ungroup() %>%
  mutate(gamma_slab = fct_relevel(gamma_slab, sort))

cstar_grid <- cstar_grid %>% 
  pivot_longer(starts_with("cstar_"),
               names_to = "parameter",
               values_to = "value")

cstar_grid %>%
  # filter(basin_AIP == "Indian") %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>%
  group_split(gamma_slab, parameter) %>%
  # head(1) %>%
  map(
    ~ map +
      geom_tile(
        data = .x,
        aes(lon_grid, lat_grid, fill = value),
        col = "grey20"
      ) +
      scale_fill_viridis_c(name = unique(.x$parameter)) +
      labs(title = paste("gamma_slab:",
                         unique(.x$gamma_slab))) +
      facet_grid(era ~ .)
  )


```

### Offset

```{r cstar_slab_distribution_offset, fig.asp=0.5}

cstar_grid_offset <- cstar_grid %>%
  pivot_wider(names_from = era,
              values_from = value) %>%
  mutate(delta_value := !!sym(tref$era[2])-!!sym(tref$era[1])) %>%
  filter(!is.na(delta_value))

cstar_grid_offset <- cstar_grid_offset %>%
  select(-tref$era) %>%
  pivot_wider(names_from = parameter,
              values_from = delta_value) %>%
  mutate(cstar_sum = cstar_tco2 + cstar_talk + cstar_phosphate) %>%
  pivot_longer(cstar_tref:cstar_sum,
               names_to = "parameter",
               values_to = "delta_value")

cstar_grid_offset %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>%
  mutate(delta_value = cut(delta_value,
                           c(-Inf, -5, -2, -1, 1, 2, 5, Inf))) %>%
  group_split(gamma_slab, parameter) %>%
  # head(1) %>%
  map(
    ~ map +
      geom_tile(
        data = .x,
        aes(lon_grid, lat_grid, fill = delta_value),
        col = "grey20"
      ) +
      scale_fill_discrete_diverging(
        palette = "Blue-Red",
        name = unique(.x$parameter),
        drop = FALSE
      ) +
      labs(title = paste("gamma_slab",
                         unique(.x$gamma_slab)))
  )

```

### Correlation

```{r correlations_contributions_cstar, fig.asp=0.5}

cstar_grid_offset %>%
  filter(parameter != "cstar_sum",
         basin_AIP == "Indian") %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>% 
  pivot_wider(names_from = parameter,
              values_from = delta_value) %>%
  rename(delta_cstar_tref = cstar_tref) %>%
  pivot_longer(cstar_tco2:cstar_phosphate,
               names_to = "parameter",
               values_to = "delta_cstar_component") %>%
  group_split(gamma_slab) %>%
  # head(1) %>%
  map(
    ~ ggplot(data = .x,
             aes(delta_cstar_tref, delta_cstar_component)) +
      geom_vline(xintercept = 0) +
      geom_hline(yintercept = 0) +
      geom_bin_2d(binwidth = 2) +
      scale_fill_viridis_c() +
      geom_smooth(method = "lm", se = FALSE, col = "red") +
      labs(title = paste(
        "basin_AIP:",
        unique(.x$basin_AIP),
        "| gamma_slab: ",
        unique(.x$gamma_slab)
      )) +
      facet_grid(. ~ parameter) +
      coord_equal()
  )


rm(cstar_grid, cstar_grid_offset)

```


## Latitudinal pattern

```{r latitudinal_cstar_pattern, fig.asp=0.5}

GLODAP_cstar %>%
  # filter(basin_AIP == "Indian") %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>% 
  select(lat, era, basin_AIP, gamma_slab, starts_with("cstar_")) %>%
  pivot_longer(starts_with("cstar_"),
               names_to = "parameter",
               values_to = "value") %>%
  group_split(basin_AIP, gamma_slab, parameter) %>%
  # head(1) %>%
  map(
    ~ ggplot(data = .x,
             aes(
               lat, value,
               col = era, fill = era
             )) +
      geom_point(shape = 21, alpha = 0.3) +
      geom_smooth(alpha = 0.3) +
      scale_color_brewer(palette = "Set1") +
      scale_fill_brewer(palette = "Set1") +
      labs(
        title = paste(
          "basin_AIP:",
          unique(.x$basin_AIP),
          "| gamma_slab: ",
          unique(.x$gamma_slab)
        ),
        y = unique(.x$parameter)
      )
  )


```



## Zonal section

### Absolute

```{r zonal_sections, fig.asp=1}

zonal_sections <- GLODAP %>% 
  mutate(depth_grid = cut(depth,
                          seq(0,1e4,500),
                          seq(250,1e4,500)),
         depth_grid = as.numeric(as.character(depth_grid)),
         lat_grid = cut(lat,
                          seq(-100,100,5),
                          seq(-97.5,100,5)),
         lat_grid = as.numeric(as.character(lat_grid))) %>% 
  group_by(lat_grid, depth_grid, era, basin_AIP) %>% 
  summarise(cstar_tref = mean(cstar_tref, na.rm = TRUE)) %>% 
  ungroup()

zonal_sections %>% 
  ggplot(aes(lat_grid , depth_grid, fill = cstar_tref)) +
  geom_tile() +
  scale_fill_viridis_c(trans = "log10") +
  scale_y_reverse() +
  labs(x = "Latitude (째N)", y = "Depth (m)") +
  coord_fixed(ratio = 1e-2, expand = 0) +
  facet_grid(basin_AIP ~ era) +
  theme(legend.position = "left")

```

### Change

```{r zonal_sections_offset, fig.asp=0.6}

zonal_sections_offset <- zonal_sections %>%
  pivot_wider(names_from = era,
              values_from = cstar_tref) %>%
  mutate(delta_cstar_tref := !!sym(tref$era[2]) - !!sym(tref$era[1])) %>%
  mutate(delta_cstar_tref = cut(delta_cstar_tref,
                           c(-Inf, -5, -2, -1, 1, 2, 5, Inf))) %>% 
  filter(!is.na(delta_cstar_tref))

zonal_sections_offset %>%
  ggplot(aes(lat_grid , depth_grid, fill = delta_cstar_tref)) +
  geom_raster() +
  scale_fill_discrete_diverging(palette = "Blue-Red",
                                drop = FALSE) +
  labs(x = "Latitude (째N)", y = "Depth (m)") +
  scale_y_reverse() +
  coord_fixed(ratio = 1e-2, expand = 0) +
  facet_grid(basin_AIP ~ .)


```


## Density distributions

### basin, gamma slab

```{r cstar_distributions}

GLODAP_data_distribution <- GLODAP %>%
  filter(data_source == "obs") %>%
  select(era,
         basin_AIP,
         gamma_slab,
         tco2,
         talk,
         phosphate,
         cstar,
         cstar_tref) %>%
  pivot_longer(tco2:cstar_tref,
               values_to = "value",
               names_to = "parameter")


GLODAP_data_distribution %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>% 
  group_split(basin_AIP, gamma_slab) %>%
  # head(1) %>% 
  map(
    ~ ggplot(data = .x) +
      geom_density(aes(value, fill = era, col = era),
                   alpha = 0.2) +
      facet_wrap(~ parameter,
                 scales = "free") +
      labs(title = paste(
        "basin_AIP:", unique(.x$basin_AIP),
        "| gamma_slab:", unique(.x$gamma_slab)
      ))
  )

rm(GLODAP_data_distribution)

```

### basin, cruise

```{r cstar_distributions_cruise, fig.asp=1, eval=FALSE}

GLODAP_data_distribution_cruise <- GLODAP %>%
  filter(data_source == "obs") %>%
  select(era,
         basin_AIP,
         gamma_slab,
         cruise,
         cstar_tref) %>% 
  mutate(cruise = as.factor(cruise))


GLODAP_data_distribution_cruise %>%
  group_split(basin_AIP, era) %>%
  # head(1) %>%
  map(
    ~ ggplot(data = .x) +
      geom_density(aes(cstar_tref, fill = cruise, col = cruise),
                   alpha = 0.2) +
      facet_wrap(~ gamma_slab,
                 scales = "free",
                 ncol = 3) +
      scale_fill_discrete(guide = FALSE) +
      scale_color_discrete(guide = FALSE) +
      labs(title = paste(
        "basin_AIP:", unique(.x$basin_AIP),
        "| cruise:", unique(.x$era)
      ))
  )

rm(GLODAP_data_distribution_cruise)

```


# Rarefication

```{r coarse_grid}

# apply coarse grid
GLODAP <- m_grid_horizontal_coarse(GLODAP)

# count data in each coarse grid element
GLODAP_grid <- GLODAP %>% 
  count(lat_grid, lon_grid, gamma_slab, era, data_source)

GLODAP_grid %>%
  ggplot(aes(n)) +
  geom_histogram(binwidth = 1) +
  facet_grid(data_source ~ .) +
  scale_y_sqrt() +
  labs(title = "Observations per era, grid cell and slab, all data")

GLODAP_grid <- GLODAP_grid %>%
  arrange(n) %>% 
  group_by(data_source) %>% 
  mutate(n_cum = cumsum(n),
         n_cum_prop = n_cum / sum(n),
         n_rank = rank(n),
         cells = n(),
         n_rank_prop = n_rank / cells) %>% 
  ungroup()

GLODAP_grid %>%
  ggplot(aes(n, n_cum, col=data_source)) +
  geom_line() +
  labs(title = "Observations per era, grid cell and slab, all data") +
  scale_color_brewer(palette = "Set1")

GLODAP_grid %>%
  ggplot(aes(n, n_cum_prop, col = data_source)) +
  geom_line() +
  labs(title = "Observations per era, grid cell and slab, all data") +
  scale_y_continuous(breaks = seq(0, 1, 0.1)) +
  scale_color_brewer(palette = "Set1")

GLODAP_grid %>%
  ggplot(aes(n_rank_prop, n_cum, col = data_source)) +
  geom_line() +
  labs(title = "Observations per era, grid cell and slab, all data") +
  scale_x_continuous(breaks = seq(0,1,0.1)) +
  scale_color_brewer(palette = "Set1")

GLODAP_grid %>%
  ggplot(aes(n_rank_prop, n_cum_prop, col = data_source)) +
  geom_line() +
  labs(title = "Observations per era, grid cell and slab, all data") +
  scale_y_continuous(breaks = seq(0,1,0.1)) +
  scale_x_continuous(breaks = seq(0,1,0.1)) +
  scale_color_brewer(palette = "Set1")


quibble <- function(x, q = seq(0.1, 0.9, 0.1)) {
  tibble(n_threshold = quantile(x, q), quantile_threshold = q)
}

GLODAP_grid_stats <- GLODAP_grid %>% 
  group_by(data_source) %>% 
  summarize(quibble(n, 
                      c(seq(0.1, 0.9, 0.1),seq(0.91,0.99,0.01)))) %>% 
  ungroup()

GLODAP_grid_stats %>% 
  ggplot(aes(quantile_threshold, n_threshold, col = data_source)) +
  geom_point() +
  geom_path() +
  scale_x_continuous(breaks = seq(0,1,0.1)) +
  scale_color_brewer(palette = "Set1")

GLODAP_grid_stats <- GLODAP_grid %>% 
  summarize(quibble(n, 
                      c(seq(0.1, 0.9, 0.1),seq(0.91,0.99,0.01))))

GLODAP_rarefication_threshold <- GLODAP_grid %>% 
  summarize(quibble(n, params_local$rarefication_threshold))

n_rarefication_threshold <- GLODAP_rarefication_threshold %>% 
  pull(n_threshold)

GLODAP_grid_stats %>% 
  ggplot(aes(quantile_threshold, n_threshold)) +
  geom_hline(data = GLODAP_rarefication_threshold,
             aes(yintercept = n_threshold), col = "red") +
  geom_vline(data = GLODAP_rarefication_threshold,
             aes(xintercept = quantile_threshold), col = "red") +
  geom_point() +
  geom_path() +
  scale_x_continuous(breaks = seq(0,1,0.1)) +
  scale_color_brewer(palette = "Set1")


rm(quibble)

```


```{r rarefication, fig.asp=0.6}

GLODAP_grid %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>% 
  group_by(gamma_slab) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ map +
      geom_raster(data = .x,
                  aes(lon_grid, lat_grid, fill = n)) +
      facet_grid(data_source ~ era) +
      scale_fill_viridis_c(trans = "log10") +
      labs(title = paste("Before rarefication | gamma_slab",
                         unique(.x$gamma_slab)))
  )

GLODAP_grid_pre_rarefication <- GLODAP_grid

GLODAP <- GLODAP %>% 
  group_by(lat_grid, lon_grid, gamma_slab, era, data_source) %>% 
  slice_sample(n = n_rarefication_threshold) %>% 
  ungroup()


GLODAP_grid <- GLODAP %>% 
  count(lat_grid, lon_grid, gamma_slab, era, data_source)

GLODAP_grid_post_rarefication <- GLODAP_grid

GLODAP_grid %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>% 
  group_by(gamma_slab) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ map +
      geom_raster(data = .x,
                  aes(lon_grid, lat_grid, fill = n)) +
      facet_grid(data_source ~ era) +
      scale_fill_viridis_c(trans = "log10") +
      labs(title = paste("After rarefication | gamma_slab",
                         unique(.x$gamma_slab)))
  )


GLODAP <- GLODAP %>% 
  select(-c(lat_grid, lon_grid))

rm(GLODAP_grid)

```


# Observations coverage

```{r obs_gamma_slab, fig.asp=0.8}

GLODAP <- GLODAP %>% 
  mutate(gamma_slab = factor(gamma_slab), 
         gamma_slab = factor(gamma_slab, levels = rev(levels(gamma_slab))))

for (i_basin in unique(GLODAP$basin)) {
  # i_basin <- unique(GLODAP$basin)[1]
  
  print(
    GLODAP %>%
      filter(basin == i_basin) %>%
      ggplot(aes(lat, gamma_slab)) +
      geom_bin2d(binwidth = 5) +
      scale_fill_viridis_c(
        option = "magma",
        direction = -1,
        trans = "log10"
      ) +
      scale_x_continuous(breaks = seq(-100, 100, 20),
                         limits = c(params_global$lat_min,
                                    params_global$lat_max)) +
      facet_grid(era ~ data_source) +
      labs(title = paste("MLR region: ", i_basin))
  )
  
}

```


## Histograms

```{r histogram_predictor, fig.asp=0.5}

GLODAP_vars <- GLODAP %>% 
  select(data_source,
         params_local$MLR_target,
         params_local$MLR_predictors)

GLODAP_vars_long <- GLODAP_vars %>%
  pivot_longer(
    cols = c(params_local$MLR_target,
             params_local$MLR_predictors),
    names_to = "variable",
    values_to = "value"
  )

GLODAP_vars_long %>% 
  ggplot(aes(value)) +
  geom_histogram() +
  facet_grid(data_source ~ variable,
             scales = "free_x")

rm(GLODAP_vars, GLODAP_vars_long)

```




# Cruise quality check

## MLR models

The the following full MLR model was fitted to all GLODAP, irrespective of the sampling era:

```{r fit_MLR_to_all_data}

#define full model
model <- paste("cstar",
               paste(params_local$MLR_predictors, collapse = " + "),
               sep = " ~ ")

model

# prepare nested data frame
GLODAP_nested <- GLODAP %>%
  group_by(gamma_slab, data_source) %>%
  nest()

# expand with model definitions
GLODAP_nested_lm <- expand_grid(GLODAP_nested,
                                model)

# fit models and extract tidy model output
GLODAP_nested_lm_fit <- GLODAP_nested_lm %>%
  mutate(
    fit = map2(.x = data, .y = model,
               ~ lm(as.formula(.y), data = .x)),
    tidied = map(fit, tidy),
    glanced = map(fit, glance),
    augmented = map(fit, augment)
  )

# extract augmented model output (fitted values and residuals)
GLODAP_augmented <- GLODAP_nested_lm_fit %>%
  select(-c(data, fit, tidied, glanced)) %>%
  unnest(augmented)

# extract input data
GLODAP_data <- GLODAP_nested_lm_fit %>%
  select(-c(fit, tidied, glanced, augmented)) %>%
  unnest(data)

# append input data with augmented data
GLODAP_augmented <- bind_cols(GLODAP_data,
                              GLODAP_augmented %>% select(.fitted, .resid))

rm(GLODAP_data)
```

### Residuals

Below, the residuals of C* from the mean C* and from C* predicted with the global model are shown.

```{r Residuals_global_c_star}

GLODAP_augmented <- GLODAP_augmented %>%
  group_by(data_source) %>% 
  mutate(cstar_minus_mean = cstar_tref - mean(cstar_tref)) %>% 
  ungroup() 

GLODAP_augmented%>% 
  ggplot(aes(year, cstar_minus_mean)) +
  geom_hline(yintercept = 0) +
  geom_bin2d(binwidth = c(1, 1)) +
  scale_fill_viridis_c() +
  facet_grid(basin_AIP ~ data_source)

GLODAP_augmented %>%
  ggplot(aes(cstar_minus_mean)) +
  geom_vline(xintercept = 0) +
  geom_histogram(binwidth = 1) +
  scale_fill_viridis_c() +
  facet_grid(basin_AIP ~ data_source)

GLODAP_augmented %>%
  ggplot(aes(year, .resid)) +
  geom_hline(yintercept = 0) +
  geom_bin2d(binwidth = c(1, 1)) +
  scale_fill_viridis_c() +
  facet_grid(basin_AIP ~ data_source)

GLODAP_augmented %>%
  ggplot(aes(.resid)) +
  geom_vline(xintercept = 0) +
  geom_histogram(binwidth = 1) +
  facet_grid(basin_AIP ~ data_source)

```

### Ranked RMSE

```{r ranked_cstar_rmse, fig.asp=0.5}


# calculate RMSE from augmented output per cruise
cruise_all <- GLODAP_augmented %>%
  group_by(cruise, data_source) %>%
  summarise(rmse = sqrt(c(crossprod(.resid)) / length(.resid))) %>%
  ungroup()

# rank RMSE
cruise_all <- cruise_all %>% 
  mutate(cruise = as.factor(cruise)) %>% 
  group_by(data_source) %>% 
  mutate(rank_rmse = rank(rmse)) %>% 
  ungroup()

cruise_out <- cruise_all %>% 
  filter(data_source == "obs",
         rmse > params_local$target_global_rmse_max)

GLODAP_out <- GLODAP_augmented %>% 
  filter(cruise %in% cruise_out$cruise)

ggplot() +
  geom_hline(yintercept = params_local$c_star_rmse_max) +
  geom_point(data = cruise_all,
             aes(rank_rmse, rmse)) +
  geom_point(data = cruise_out,
             aes(rank_rmse, rmse, col = cruise)) +
  facet_grid(. ~ data_source)


```

## Removed cruises


```{r cstar_rmse_removed_cruises, fig.asp=1}

cruise_removal_ratio <- nrow(GLODAP_out)/nrow(GLODAP_augmented)*100

stats_MLR_cleaning_cruises <- tibble(
  cruise_removal_ratio = cruise_removal_ratio,
  cruise_removal_n = length(cruise_out)
)

stats_MLR_cleaning_cruises

cruise_removal_grid <- GLODAP_out %>%
  distinct(lat, lon, era, cruise)

map +
  geom_raster(data = GLODAP %>% distinct(lat, lon, era),
              aes(lon, lat), fill = "grey70") +
  geom_raster(data = cruise_removal_grid,
              aes(lon, lat), fill = "red") +
  facet_wrap( ~ era, ncol = 1) +
  labs(title = "Maps of removed cruises")


```

```{r clean_GLODAP}

# select relevant columns
GLODAP <- GLODAP %>%
  filter(!(cruise %in% cruise_out$cruise)) %>%
  select(
    year,
    date,
    era,
    basin,
    basin_AIP,
    lat,
    lon,
    depth,
    data_source,
    gamma,
    gamma_slab,
    params_local$MLR_predictors,
    params_local$MLR_target
  )

```


# Create observation grids

Grid containing all grid cells where at least one observation remains available after cleaning.

```{r create_clean_GLODAP_grids}

GLODAP_grid <- GLODAP %>% 
  distinct(lat, lon)

GLODAP_grid_era <- GLODAP %>% 
  distinct(lat, lon, era)

GLODAP_grid_era_gamma <- GLODAP %>% 
  distinct(lat, lon, era, gamma_slab)

```


# Write files

```{r write_csv_GLODAP_used_for_fitting}


GLODAP %>% write_csv(paste(
  path_version_data,
  "GLODAPv2.2020_MLR_fitting_ready.csv",
  sep = ""
))

GLODAP_grid  %>%
  write_csv(paste(path_version_data,
                  "GLODAPv2.2020_clean_obs_grid.csv",
                  sep = ""))

GLODAP_grid_pre_rarefication  %>%
  write_csv(paste(path_version_data,
                  "GLODAP_grid_pre_rarefication.csv",
                  sep = ""))

GLODAP_grid_post_rarefication  %>%
  write_csv(paste(path_version_data,
                  "GLODAP_grid_post_rarefication.csv",
                  sep = ""))

GLODAP_grid_era  %>%
  write_csv(paste(path_version_data,
                  "GLODAPv2.2020_clean_obs_grid_era.csv",
                  sep = ""))

GLODAP_grid_era_gamma  %>%
  write_csv(paste(path_version_data,
                  "GLODAPv2.2020_clean_obs_grid_era_gamma.csv",
                  sep = ""))

mean_gamma_offset_Atl  %>%
  write_rds(paste(path_version_data,
                  "mean_gamma_offset_Atl.rds",
                  sep = ""))

mean_gamma_offset_Indo_Pac  %>%
  write_rds(paste(path_version_data,
                  "mean_gamma_offset_Indo_Pac.rds",
                  sep = ""))

co2_atm_tref %>%  write_csv(paste(path_version_data,
                                  "co2_atm_tref.csv",
                                  sep = ""))

disequi_pCO2_tref  %>%  write_csv(paste(path_version_data,
                                        "disequi_pCO2_tref.csv",
                                        sep = ""))

tcant_3d %>%  write_csv(paste(path_version_data,
                             "projected_tcant_3d_tref.csv",
                             sep = ""))

tcant_zonal %>%  write_csv(paste(path_version_data,
                             "projected_tcant_zonal_tref.csv",
                             sep = ""))


stats_MLR_cleaning_cruises  %>%  write_csv(paste(
  path_version_data,
  "MLR_cleaning_cruise_removal_stats.csv",
  sep = ""
))

cruise_removal_grid  %>%  write_csv(paste(
  path_version_data,
  "MLR_cleaning_cruise_removal_grid.csv",
  sep = ""
))


```
