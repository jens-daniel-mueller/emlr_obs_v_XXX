---
title: "Mapping target variable"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
params:
  Version_ID: "v_XXX"
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}

if (params$Version_ID == "v_XXX") {
  params_local <-
    read_rds(here::here("data/auxillary", "params_local.rds"))
  
} else {
  params_local <-
    read_rds(
      file = paste(path_root, "observations",
                   params$Version_ID,
                   "data/params_local.rds",
                   sep = "/")
    )
}

if (params_local$gobm == "CESM-ETHZ_v20211122_monthly") {
  params_local$gobm <- "CESM-ETHZ_v20211122"
}

```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

path_version_figures  <-
  paste(path_observations,
        params_local$Version_ID,
        "/figures/",
        sep = "")
```

# Scope

Map 3d fields of the predicted target variable (either tco2, cstar or cstar_tref) based on fitted MLRs and climatological fields of predictor variables. In contrast to the direct Cant calculation based on coefficient differences, we apply here the fitted coefficients directly. Cant could also be estimates as the differences between the target variable fields mapped here.

# Required data

## Cstar mod_truth

```{r cstar_mod_truth}

dcant_3d_cstar <-
  read_csv(paste(path_version_data,
                  "dcant_3d_cstar.csv", sep = ""))


```


## Predictor fields

Currently, we use following combined predictor fields:

- WOA18: S, T, and derived variables
- GLODAP16: Oxygen, PO4, NO3, Silicate, and derived variables

```{r read_predictor_file}

predictors <-
  read_csv(paste(path_version_data,
                 "W18_st_G16_opsn.csv",
                 sep = ""))

```


## MLR models

```{r load_eMLR_models}

lm_best_target <-
  read_csv(paste(path_version_data,
                 "lm_best_target.csv",
                 sep = ""))

```

## Others

```{r read_other_data}

tref  <-
  read_csv(paste(path_version_data,
                 "tref.csv",
                 sep = ""))

```



# Join MLR + climatologies

```{r merge_model_coeff_predictor_climatology}

# remove predictor variable from model
lm_best_target <- lm_best_target %>%
  mutate(model = str_remove(model, paste(params_local$MLR_target, "~ ")))

# join predictors and MLR
target <- full_join(predictors, lm_best_target)

rm(predictors, lm_best_target)

```


# Map target variable

## Apply MLRs to predictor

```{r calc_target_variable}

target <- b_target_model(target)

target <- target %>%
  select(data_source,
         lon,
         lat,
         depth,
         era,
         basin,
         basin_AIP,
         gamma,
         params_local$MLR_target)

```

## Average model target variable

```{r calc_target_variable_mean}

target_3d <- m_target_model_average(target)
target_3d <- m_cut_gamma(target_3d, "gamma")

rm(target)

```

## Zonal mean sections

For each basin and era combination, the zonal mean of the target variable is calculated. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r Calculate_target_mean_sections}

target_zonal <- target_3d %>%
  group_by(data_source, era) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(zonal)

target_zonal <- m_cut_gamma(target_zonal, "gamma_mean")

target_zonal %>%
  ggplot(aes_string(paste0(params_local$MLR_target, "_mean"), col = "era")) +
  geom_density() +
  facet_grid(. ~ data_source)

target_zonal %>%
  group_by(basin_AIP) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ p_section_zonal_continous_depth(
      df = .x,
      var = paste0(params_local$MLR_target, "_mean"),
      breaks = seq(740, 940, 20),
      plot_slabs = "n",
      subtitle_text = paste("basin:",
                            unique(.x$basin_AIP))
    ) +
      facet_grid(era ~ data_source)
  )

```

## Profiles

For each basin, the mean (+ min and max) dcant profile is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r calc_target_profiles_basin_AIP}

var <- sym(params_local$MLR_target)

target_profile <- target_3d %>%
  mutate(area = earth_surf(lat, lon),
         !!paste0(var, "_scaled") :=
           !!var * area) %>%
  group_by(data_source, basin_AIP, depth) %>%
  summarise(!!paste0(var, "_sd") := sqrt(Hmisc::wtd.var(!!var, area, na.rm = TRUE)),
            !!var := sum(!!sym(paste0(var, "_scaled"))) / sum(area)) %>%
  ungroup()


```


```{r calc_target_profiles_MLR_regions}

target_profile_basin_MLR <-
  full_join(
    target_3d %>% select(data_source, lon, lat, depth, !!var),
    basinmask %>% select(MLR_basins, basin, lon, lat)
  ) %>%
  mutate(area = earth_surf(lat, lon),
         !!paste0(var, "_scaled") :=
           !!var * area) %>%
  drop_na() %>%
  group_by(data_source, basin, MLR_basins, depth) %>%
  summarise(!!paste0(var, "_sd") := sqrt(Hmisc::wtd.var(!!var, area, na.rm = TRUE)),
            !!var := sum(!!sym(paste0(var, "_scaled"))) / sum(area)) %>%
  ungroup()


```


# Join true C*


```{r join_cstar_true_and_predicted}

dcant_3d_cstar <- dcant_3d_cstar %>% 
  mutate(data_source = if_else(data_source == "po4",
                               "phosphate",
                               "nitrate")) %>% 
  filter(data_source == params_local$cstar_nutrient)

dcant_3d_cstar <- dcant_3d_cstar %>% 
  select(lon:cstar_tref_2, -c(data_source, method)) %>% 
  pivot_longer(starts_with("cstar_tref_"),
               values_to = "cstar_tref_mod_truth",
               names_to = "era",
               names_prefix = "cstar_tref_") %>% 
  mutate(era = if_else(era == "1",
                       unique(tref$era[1]),
                       unique(tref$era[2])))

target_3d <- inner_join(
  target_3d %>% 
    filter(data_source == "mod") %>% 
    select(-data_source),
  dcant_3d_cstar
)

target_3d <- target_3d %>% 
  mutate(dcant = cstar_tref - cstar_tref_mod_truth) %>% 
  select(lat, lon, depth, basin_AIP, era, gamma, dcant)

target_3d <- target_3d %>%
  mutate(dcant_pos = dcant)

target_3d <- m_cut_gamma(target_3d %>% rename(gamma_mean = gamma), "gamma_mean")

target_3d <-
  target_3d %>% rename(gamma = gamma_mean)

```

# Zonal mean sections

For each basin and era combination, the zonal mean of the target variable is calculated. Likewise, sd is calculated for the averaging of the mean basin fields.

## C* bias

```{r calculate_target_3d_mean_sections}

target_zonal <- target_3d %>%
  group_by(era) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(zonal)

target_zonal <- m_cut_gamma(target_zonal, "gamma_mean")

target_zonal %>%
  ggplot(aes(dcant_mean, col = era)) +
  geom_density()


target_zonal %>%
  group_by(basin_AIP) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ p_section_zonal_continous_depth(
      df = .x,
      var = "dcant_mean",
      col = "divergent",
      plot_slabs = "n",
      subtitle_text = paste("basin:",
                            unique(.x$basin_AIP))
    ) +
      facet_grid(era ~ .)
  )

```

## C* bias offset

```{r calculate_target_3d_mean_sections_offset, fig.asp=1}

target_zonal <- target_zonal %>% 
  arrange(basin_AIP, lat, depth, era) %>% 
  group_by(basin_AIP, lat, depth) %>% 
  mutate(dcant_mean_bias = dcant_mean - lag(dcant_mean)) %>% 
  ungroup()

target_zonal %>%
  ggplot() +
  geom_density(aes(dcant_mean, col = era)) +
  geom_density(aes(dcant_mean_bias, col = "bias"))


target_zonal %>%
  filter(!is.na(dcant_mean_bias)) %>%
  p_section_zonal_continous_depth(var = "dcant_mean_bias",
                                  col = "divergent",
                                  plot_slabs = "n") +
  facet_grid(basin_AIP ~ .)

```

# Profiles

For each basin and era combination, the mean profile of the target variable is calculated. Likewise, sd is calculated for the averaging of the mean basin fields.

## C* bias

```{r calc_dcant_profiles}

target_profile <- target_3d %>%
  mutate(area = earth_surf(lat, lon),
         dcant_scaled = dcant * area) %>% 
  group_by(era, basin_AIP, depth) %>% 
  summarise(dcant_sd = sqrt(
              Hmisc::wtd.var(dcant, area, na.rm = TRUE)),
            dcant = sum(dcant_scaled) / sum(area)) %>% 
  ungroup()

target_profile %>%
  ggplot(aes(dcant, depth,
             col = era, fill=era)) +
  geom_vline(xintercept = 0) +
  geom_ribbon(aes(xmin = dcant - dcant_sd,
                  xmax = dcant + dcant_sd),
              alpha = 0.2,
              col = "transparent") +
  geom_path() +
  scale_y_reverse() +
  facet_grid( ~ basin_AIP)

```


```{r calc_dcant_profiles_MLR_regions}

target_profile_basin_MLR <-
  full_join(
    target_3d %>% select(era, lon, lat, depth, dcant),
    basinmask %>% select(MLR_basins, basin, lon, lat)
  ) %>%
  mutate(area = earth_surf(lat, lon),
         dcant_scaled = dcant * area) %>% 
  group_by(era, basin, MLR_basins, depth) %>% 
  summarise(dcant_sd = sqrt(
              Hmisc::wtd.var(dcant, area, na.rm = TRUE)),
            dcant = sum(dcant_scaled) / sum(area)) %>% 
  ungroup()

target_profile_basin_MLR %>%
  filter(MLR_basins == "5") %>%
  ggplot(aes(dcant, depth,
             col = era, fill = era)) +
  geom_vline(xintercept = 0) +
  geom_ribbon(aes(xmin = dcant - dcant_sd,
                  xmax = dcant + dcant_sd),
              alpha = 0.2,
              col = "transparent") +
  geom_path() +
  scale_y_reverse() +
  facet_grid(~ basin)

```



## C* bias offset

```{r calculate_target_3d_profile_offset}

target_profile <- target_profile %>% 
  arrange(basin_AIP, depth, era) %>% 
  group_by(basin_AIP, depth) %>% 
  mutate(dcant_bias = dcant - lag(dcant)) %>% 
  ungroup()

target_profile %>%
  filter(!is.na(dcant_bias)) %>%
  ggplot(aes(dcant_bias, depth)) +
  geom_vline(xintercept = 0) +
  geom_path() +
  scale_y_reverse() +
  facet_grid( ~ basin_AIP)

```


```{r calculate_target_3d_profile_offset_MLR_regions}

target_profile_basin_MLR <- target_profile_basin_MLR %>% 
  arrange(basin, MLR_basins, depth, era) %>% 
  group_by(basin, MLR_basins, depth) %>% 
  mutate(dcant_bias = dcant - lag(dcant)) %>% 
  ungroup()

target_profile_basin_MLR %>%
  filter(MLR_basins == "5",
         !is.na(dcant_bias)) %>%
  ggplot(aes(dcant_bias, depth)) +
  geom_vline(xintercept = 0) +
  geom_path() +
  scale_y_reverse() +
  facet_grid(~ basin)

```


# Inventory calculation

To calculate dcant column inventories, we:  

1. Convert dcant concentrations to volumetric units
2. Multiply layer thickness with volumetric dcant concentration to get a layer inventory
3. For each horizontal grid cell and era, sum dcant layer inventories for different inventory depths (`r params_global$inventory_depths` m)

Step 2 is performed separately for all dcant and positive dcant values only.

## C* bias

```{r calculate_target_inventory, fig.asp=1}

target_inv <- target_3d %>%
  group_by(era) %>%
  nest() %>%
  mutate(inv = map(.x = data, ~m_dcant_inv(.x))) %>%
  select(-data) %>%
  unnest(inv)

p_map_cant_inv(df = target_inv,
               var = "dcant",
               col = "bias",
               subtitle_text = "for predefined integration depths") +
  facet_grid(inv_depth ~ era)


```

## C* bias offset

```{r calculate_target_inventory_offset}

target_inv <- target_inv %>% 
  arrange(era) %>% 
  group_by(basin_AIP, lat, lon, inv_depth) %>% 
  mutate(dcant_mean_bias = dcant - lag(dcant)) %>% 
  ungroup()

target_inv %>%
  ggplot() +
  geom_density(aes(dcant, col = era)) +
  geom_density(aes(dcant_mean_bias, col = "bias"))


p_map_cant_inv(df = target_inv %>% filter(!is.na(dcant_mean_bias)),
               var = "dcant_mean_bias",
               col = "bias",
               subtitle_text = "for predefined integration depths") +
  facet_grid(inv_depth ~ .)

```


# Slap concentrations

```{r calculate_gamma_slab_maps}

target_slab <- target_3d %>%
  mutate(dcant_sd = 0,
         dcant_pos_sd = 0) %>% 
  group_by(era) %>%
  nest() %>%
  mutate(slab = map(.x = data, ~ m_dcant_slab_concentration(.x))) %>%
  select(-data) %>%
  unnest(slab)
```

## C* bias

```{r dcant_all_gamma_slab_maps, fig.asp=1}

target_slab %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>%
  group_by(gamma_slab) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ p_map_dcant_slab(
      df = .x,
      var = "dcant",
      col = "bias",
      subtitle_text = paste("Neutral density:",
                            unique(.x$gamma_slab))
    ) +
      facet_grid(era~.)
  )



```

## C* bias offset

```{r dcant_gamma_slab_maps_bias}

target_slab <- target_slab %>% 
  arrange(era) %>% 
  group_by(lat, lon, gamma_slab) %>% 
  mutate(dcant_mean_bias = dcant - lag(dcant)) %>% 
  ungroup()

target_slab %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>%
  group_split(gamma_slab) %>%
  # head(1) %>%
  map(~ p_map_dcant_slab(
    df = .x,
    var = "dcant_mean_bias",
    col = "divergent",
    subtitle_text = paste("Neutral density:", unique(.x$gamma_slab))
  ))


```


# Budgets

Global dcant budgets were estimated in units of Pg C. Please note that here we added dcant (all vs postitive only) values and do not apply additional corrections for areas not covered.

```{r budget_global}

target_inv <- target_inv %>%
  filter(!is.na(dcant_mean_bias)) %>%
  select(era, lon, lat, basin_AIP, inv_depth, dcant = dcant_mean_bias) %>%
  mutate(data_source = "mod",
         method = "total",
         dcant_pos = dcant)

target_budget_global <- m_dcant_budget(target_inv)

target_budget_global <- target_budget_global %>%
  mutate(inv_depth = as.factor(inv_depth))

target_budget_global %>%
  filter(estimate == "dcant") %>% 
  ggplot() +
  scale_fill_viridis_d() +
  geom_col(aes(value, inv_depth)) +
  scale_y_discrete(limits=rev)

```


```{r budget_basin_AIP}

target_budget_basin_AIP <- target_inv %>% 
  group_by(basin_AIP) %>%
  nest() %>% 
  mutate(budget = map(.x = data, ~m_dcant_budget(.x))) %>% 
  select(-data) %>%
  unnest(budget) %>% 
  ungroup()

target_budget_basin_AIP <- target_budget_basin_AIP %>% 
  mutate(inv_depth = as.factor(inv_depth))

target_budget_basin_AIP %>%
  filter(estimate == "dcant") %>% 
  ggplot() +
  geom_vline(xintercept = 0) +
  scale_fill_viridis_d() +
  geom_col(aes(value, inv_depth)) +
  scale_y_discrete(limits=rev) +
  facet_grid(.~basin_AIP)

```


```{r budget_MLR_regions}


target_budget_basin_MLR <-
  full_join(target_inv, basinmask) %>%
  filter(!is.na(dcant)) %>% 
  group_by(basin, MLR_basins) %>%
  nest() %>%
  mutate(budget = map(.x = data, ~ m_dcant_budget(.x))) %>%
  select(-data) %>%
  unnest(budget)

target_budget_basin_MLR <- target_budget_basin_MLR %>% 
  mutate(inv_depth = as.factor(inv_depth))

target_budget_basin_MLR %>%
  filter(estimate == "dcant",
         MLR_basins == "5") %>% 
  ggplot() +
  geom_vline(xintercept = 0) +
  scale_fill_viridis_d() +
  geom_col(aes(value, inv_depth)) +
  scale_y_discrete(limits=rev) +
  facet_grid(basin~MLR_basins)

```

# Write csv

```{r write_target_files}

target_3d %>%
  write_csv(paste(path_version_data,
                  "target_3d.csv",
                  sep = ""))

target_zonal %>%
  write_csv(paste(path_version_data,
                  "target_zonal.csv",
                  sep = ""))

target_profile %>%
  write_csv(paste(path_version_data,
                  "target_profile.csv", sep = ""))

target_profile_basin_MLR %>%
  write_csv(paste(path_version_data,
                  "target_profile_basin_MLR.csv", sep = ""))

target_inv %>%
  write_csv(paste(path_version_data,
                  "target_inv.csv", sep = ""))

target_slab %>%
  write_csv(paste(path_version_data,
                  "target_slab.csv", sep = ""))

target_budget_basin_MLR %>%
  write_csv(paste(path_version_data,
                  "target_budget_basin_MLR.csv", sep = ""))

target_budget_basin_AIP %>%
  write_csv(paste(path_version_data,
                  "target_budget_basin_AIP.csv", sep = ""))

target_budget_global %>%
  write_csv(paste(path_version_data,
                  "target_budget_global.csv", sep = ""))


```
