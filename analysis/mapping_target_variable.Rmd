---
title: "Mapping target variable"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}
params_local <-
  read_rds(here::here("data/auxillary",
                       "params_local.rds"))

```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

path_version_figures  <-
  paste(path_observations,
        params_local$Version_ID,
        "/figures/",
        sep = "")
```

# Scope

Map 3d fields of the predicted target variable (either tco2, cstar or cstar_tref) based on fitted MLRs and climatological fields of predictor variables. In contrast to the direct Cant calculation based on coefficient differences, we apply here the fitted coefficients directly. Cant could also be estimates as the differences between the target variable fields mapped here.

# Required data

## Cstar mod_truth

```{r cstar_mod_truth}

dcant_3d_cstar <-
  read_csv(paste(path_version_data,
                  "dcant_3d_cstar.csv", sep = ""))


```


## Predictor fields

Currently, we use following combined predictor fields:

- WOA18: S, T, and derived variables
- GLODAP16: Oxygen, PO4, NO3, Silicate, and derived variables

```{r read_predictor_file}

predictors <-
  read_csv(paste(path_version_data,
                 "W18_st_G16_opsn.csv",
                 sep = ""))

```


## MLR models

```{r load_eMLR_models}

lm_best_target <-
  read_csv(paste(path_version_data,
                 "lm_best_target.csv",
                 sep = ""))

```

## Others

```{r read_other_data}

tref  <-
  read_csv(paste(path_version_data,
                 "tref.csv",
                 sep = ""))

```



# Join MLR + climatologies

```{r merge_model_coeff_predictor_climatology}

# remove predictor variable from model
lm_best_target <- lm_best_target %>%
  mutate(model = str_remove(model, paste(params_local$MLR_target, "~ ")))

# join predictors and MLR
target <- full_join(predictors, lm_best_target)

rm(predictors, lm_best_target)

```


# Map target variable

## Apply MLRs to predictor

```{r calc_target_variable}

target <- b_target_model(target)

target <- target %>%
  select(data_source,
         lon,
         lat,
         depth,
         era,
         basin,
         basin_AIP,
         gamma,
         params_local$MLR_target)

```

## Average model target variable

```{r calc_target_variable_mean}

target_average <- m_target_model_average(target)
target_average <- m_cut_gamma(target_average, "gamma")

rm(target)

```

## Zonal mean sections

For each basin and era combination, the zonal mean of the target variable is calculated. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r Calculate_target_mean_sections}

target_average_zonal <- target_average %>%
  group_by(data_source, era) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(zonal)

target_average_zonal <- m_cut_gamma(target_average_zonal, "gamma_mean")

target_average_zonal %>%
  ggplot(aes_string(paste0(params_local$MLR_target, "_mean"), col = "era")) +
  geom_density() +
  facet_grid(. ~ data_source)

target_average_zonal %>%
  group_by(basin_AIP, data_source, era) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ p_section_zonal_continous_depth(
      df = .x,
      var = paste0(params_local$MLR_target, "_mean"),
      breaks = seq(740,940,20),
      plot_slabs = "n",
      subtitle_text = paste(
        "data_source: ",
        unique(.x$data_source),
        "| era: ",
        unique(.x$era),
        "| basin:",
        unique(.x$basin_AIP)
      )
    )
  )

```

## Profiles

For each basin, the mean (+ min and max) dcant profile is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r calc_target_profiles_basin_AIP}

var <- sym(params_local$MLR_target)

target_average_profile <- target_average %>%
  mutate(area = earth_surf(lat, lon),
         !!paste0(var, "_scaled") :=
           !!var * area) %>%
  group_by(data_source, basin_AIP, depth) %>%
  summarise(!!paste0(var, "_sd") := sqrt(Hmisc::wtd.var(!!var, area, na.rm = TRUE)),
            !!var := sum(!!sym(paste0(var, "_scaled"))) / sum(area)) %>%
  ungroup()


```


```{r calc_target_profiles_MLR_regions}

target_average_basin_MLR <-
  full_join(
    target_average %>% select(data_source, lon, lat, depth, !!var),
    basinmask %>% select(MLR_basins, basin, lon, lat)
  ) %>%
  mutate(area = earth_surf(lat, lon),
         !!paste0(var, "_scaled") :=
           !!var * area) %>%
  drop_na() %>%
  group_by(data_source, basin, MLR_basins, depth) %>%
  summarise(!!paste0(var, "_sd") := sqrt(Hmisc::wtd.var(!!var, area, na.rm = TRUE)),
            !!var := sum(!!sym(paste0(var, "_scaled"))) / sum(area)) %>%
  ungroup()


```


# Join true C*


```{r join_cstar_true_and_predicted}

unique(tref$era[1])

dcant_3d_cstar <- dcant_3d_cstar %>% 
  mutate(data_source = if_else(data_source == "po4",
                               "phosphate",
                               "nitrate")) %>% 
  filter(data_source == params_local$cstar_nutrient)

dcant_3d_cstar <- dcant_3d_cstar %>% 
  select(lon:cstar_tref_2, -c(data_source, method)) %>% 
  pivot_longer(starts_with("cstar_tref_"),
               values_to = "cstar_tref_mod_truth",
               names_to = "era",
               names_prefix = "cstar_tref_") %>% 
  mutate(era = if_else(era == "1",
                       unique(tref$era[1]),
                       unique(tref$era[2])))

target_bias <- inner_join(
  target_average %>% 
    filter(data_source == "mod") %>% 
    select(-data_source),
  dcant_3d_cstar
)

target_bias <- target_bias %>% 
  mutate(dcant = cstar_tref - cstar_tref_mod_truth) %>% 
  select(lat, lon, depth, basin_AIP, era, gamma, dcant)

```

## Zonal mean sections

For each basin and era combination, the zonal mean of the target variable is calculated. Likewise, sd is calculated for the averaging of the mean basin fields.

### C* bias

```{r Calculate_target_bias_mean_sections}

target_bias_zonal <- target_bias %>%
  group_by(era) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(zonal)

target_bias_zonal <- m_cut_gamma(target_bias_zonal, "gamma_mean")

target_bias_zonal %>%
  ggplot(aes(dcant_mean, col = era)) +
  geom_density()


target_bias_zonal %>%
  group_by(basin_AIP, era) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ p_section_zonal_continous_depth(
      df = .x,
      var = "dcant_mean",
      col = "divergent",
      plot_slabs = "n",
      subtitle_text = paste(
        "era: ",
        unique(.x$era),
        "| basin:",
        unique(.x$basin_AIP)
      )
    )
  )

```

### C* bias offset

```{r Calculate_target_bias_mean_sections_offset}

target_bias_zonal <- target_bias_zonal %>% 
  arrange(basin_AIP, lat, depth, era) %>% 
  group_by(basin_AIP, lat, depth) %>% 
  mutate(dcant_mean_bias = dcant_mean - lag(dcant_mean)) %>% 
  ungroup()

target_bias_zonal %>%
  ggplot() +
  geom_density(aes(dcant_mean, col = era)) +
  geom_density(aes(dcant_mean_bias, col = "bias"))


target_bias_zonal %>%
  filter(!is.na(dcant_mean_bias)) %>%
  group_by(basin_AIP) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ p_section_zonal_continous_depth(
      df = .x,
      var = "dcant_mean_bias",
      col = "divergent",
      plot_slabs = "n",
      subtitle_text = paste("basin:",
                            unique(.x$basin_AIP))
    )
  )

```



# Write csv

```{r write_target_files}

target_average %>%
  write_csv(paste(path_version_data,
                  "target_3d.csv",
                  sep = ""))

target_average_zonal %>%
  write_csv(paste(path_version_data,
                  "target_zonal.csv",
                  sep = ""))

target_average_profile %>%
  write_csv(paste(path_version_data,
                  "target_average_profile.csv", sep = ""))

target_average_basin_MLR %>%
  write_csv(paste(path_version_data,
                  "target_average_profile_basin_MLR.csv", sep = ""))


```
