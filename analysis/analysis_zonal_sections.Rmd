---
title: "Analysis of dcant estimates"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
params:
  Version_ID: "v_XXX"
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}

if (params$Version_ID == "v_XXX") {
  params_local <-
    read_rds(here::here("data/auxillary", "params_local.rds"))
  
} else {
  params_local <-
    read_rds(
      file = paste(path_root, "observations",
                   params$Version_ID,
                   "data/params_local.rds",
                   sep = "/")
    )
}

```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

path_version_figures  <-
  paste(path_observations,
        params_local$Version_ID,
        "/figures/",
        sep = "")
```

```{r load_libraries_specific, include = FALSE}
library(scales)
library(marelac)
library(kableExtra)
library(gt)
```

# Version ID

The results displayed on this site correspond to the Version_ID: `r params$Version_ID`

# Data sources

dcant estimates from this sensitivity case:

- Mean and SD per grid cell (lat, lon, depth)
- Zonal mean and SD (basin, lat, depth)
- Inventories (lat, lon)


```{r read_dcant_files}

dcant_zonal <-
  read_csv(paste(path_version_data,
                 "dcant_zonal.csv",
                 sep = ""))

dcant_zonal_mod_truth <-
  read_csv(paste(path_version_data,
                 "dcant_zonal_mod_truth.csv",
                 sep = ""))

dcant_zonal <- bind_rows(dcant_zonal,
                        dcant_zonal_mod_truth)


target_zonal <-
  read_csv(paste(path_version_data,
                 "target_zonal.csv",
                 sep = ""))

dcant_zonal_cstar <-
  read_csv(paste(path_version_data,
                  "dcant_zonal_cstar.csv", sep = ""))

dcant_zonal_cstar <- bind_rows(dcant_zonal_mod_truth, dcant_zonal_cstar)
# dcant_inv_cstar <- bind_rows(dcant_inv_read %>% filter(data_source == "mod")
#                              , dcant_inv_cstar)


dcant_profile <-
  read_csv(paste(path_version_data,
                 "dcant_profile.csv",
                 sep = ""))

dcant_profile_mod_truth <-
  read_csv(paste(path_version_data,
                 "dcant_profile_mod_truth.csv",
                 sep = ""))

dcant_profile <- bind_rows(dcant_profile,
                        dcant_profile_mod_truth)

target_profile <-
  read_csv(paste(path_version_data,
                 "target_profile.csv",
                 sep = ""))


dcant_zonal_method <-
  read_csv(paste(path_version_data,
                 "dcant_zonal_method.csv",
                 sep = ""))

dcant_zonal_mod_truth_method <-
  read_csv(paste(path_version_data,
                 "dcant_zonal_mod_truth_method.csv",
                 sep = ""))


surface_data <- nrow(dcant_zonal_mod_truth_method %>% 
                       filter(method == "surface")) > 0

dcant_zonal_method <- bind_rows(dcant_zonal_method,
                        dcant_zonal_mod_truth_method)


```

# dcant - positive

In a first series of plots we explore the distribution of dcant, taking only positive estimates into account (positive here refers to the mean dcant estimate across MLR model predictions available for each grid cell). Negative values were set to zero before calculating mean sections and inventories.


```{r dcant_pos_zonal_mean_sections, fig.asp=0.6}

dcant_pos_zonal_bias <- dcant_zonal %>%
  filter(data_source %in% c("mod", "mod_truth")) %>%
  select(lat, depth, basin_AIP, data_source, dcant_pos) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant_pos) %>%
  mutate(dcant_pos_bias = mod - mod_truth)

dcant_pos_zonal_bias <- full_join(
  dcant_pos_zonal_bias,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)


for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  for (i_data_source in unique(dcant_zonal$data_source)) {
    # i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]
    # i_data_source <- unique(dcant_zonal$data_source)[1]
    
    print(
      p_section_zonal(
        df = dcant_zonal %>%
          filter(basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant_pos",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source)
      )
    )
    
  }
  print(
    p_section_zonal(
      df = dcant_pos_zonal_bias %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_pos_bias",
      col = "divergent",
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
}

```


# dcant - all

In a second series of plots we explore the distribution of all dcant, taking positive and negative estimates into account.

```{r dcant_all_zonal_mean_sections, fig.asp=0.6}

dcant_zonal_bias <- dcant_zonal %>%
  filter(data_source %in% c("mod", "mod_truth")) %>%
  select(lat, depth, basin_AIP, data_source, dcant) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant) %>%
  mutate(dcant_bias = mod - mod_truth)

dcant_zonal_bias <- full_join(
  dcant_zonal_bias,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)


dcant_zonal_cstar <- dcant_zonal_cstar %>%
  mutate(
    data_source = case_when(
      data_source == "po4" ~ "phosphate",
      data_source == "no3" ~ "nitrate",
      TRUE                 ~ data_source
    )
  )

dcant_zonal_bias_cstar <- dcant_zonal_cstar %>%
  filter(data_source %in% c("mod_truth", params_local$cstar_nutrient)) %>%
  select(lat, depth, basin_AIP, data_source, dcant, gamma_mean) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant) %>%
  mutate(dcant_bias = !!sym(params_local$cstar_nutrient) - mod_truth) %>%
  drop_na()

# i_data_source <- unique(dcant_zonal$data_source)[1]
# i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]

for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  
  for (i_data_source in unique(dcant_zonal$data_source)) {
  
    print(
      p_section_zonal(
        df = dcant_zonal %>%
          filter(basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant",
        gamma = "gamma_mean",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source)
      )
    )
    
  }
  
  print(
    p_section_zonal(
      df = dcant_zonal_bias %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_bias",
      col = "divergent",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
  
  print(
    p_section_zonal(
      df = target_zonal %>%
        filter(basin_AIP == i_basin_AIP,
               !is.na(dcant_mean_bias)),
      var = "dcant_mean_bias",
      col = "divergent",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: delta C* prediction bias")
    )
  )
  
  print(
    p_section_zonal(
      df = dcant_zonal_bias_cstar %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_bias",
      col = "divergent",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod_truth - delta C* |",
    params_local$cstar_nutrient)
    )
  )
  
}
  
```


## Surface


```{r dcant_all_zonal_mean_sections_surface, fig.asp=0.6, eval=surface_data}

dcant_zonal_bias_method_surface <- dcant_zonal_method %>%
  filter(data_source %in% c("mod", "mod_truth"),
         method == "surface") %>%
  select(lat, depth, basin_AIP, data_source, dcant) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant) %>%
  mutate(dcant_bias = mod - mod_truth)

dcant_zonal_bias_method_surface <- full_join(
  dcant_zonal_bias_method_surface,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)

# i_data_source <- unique(dcant_zonal$data_source)[1]
# i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]

for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  for (i_data_source in unique(dcant_zonal$data_source)) {
    print(
      p_section_zonal(
        df = dcant_zonal_method %>%
          filter(method == "surface",
                 basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant",
        plot_slabs = "n",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source))
    )
    
  }
  
    print(
    p_section_zonal(
      df = dcant_zonal_bias_method_surface %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_bias",
      col="divergent",
      plot_slabs = "n",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
  
}
  
```

## Deep


```{r dcant_all_zonal_mean_sections_deep, fig.asp=0.6}

dcant_zonal_bias_method_deep <- dcant_zonal_method %>%
  filter(data_source %in% c("mod", "mod_truth"),
         method == "eMLR") %>%
  select(lat, depth, basin_AIP, data_source, dcant) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant) %>%
  mutate(dcant_bias = mod - mod_truth)

dcant_zonal_bias_method_deep <- full_join(
  dcant_zonal_bias_method_deep,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)

# i_data_source <- unique(dcant_zonal$data_source)[1]
# i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]

for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  for (i_data_source in unique(dcant_zonal$data_source)) {
    print(
      p_section_zonal(
        df = dcant_zonal_method %>%
          filter(method == "eMLR",
                 basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source))
    )
    
  }
  
    print(
    p_section_zonal(
      df = dcant_zonal_bias_method_deep %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_bias",
      col="divergent",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
  
}
  
```

# Profiles

## dCant

```{r dcant_profiles}

dcant_profile %>%
  ggplot(aes(dcant, depth,
             col = data_source, fill=data_source)) +
  geom_vline(xintercept = 0) +
  geom_ribbon(aes(xmin = dcant - dcant_sd,
                  xmax = dcant + dcant_sd),
              alpha = 0.2,
              col = "transparent") +
  geom_path() +
  scale_y_reverse() +
  facet_grid( ~ basin_AIP)

```

## Target

```{r target_dcant_profiles, eval=FALSE}

target_profile %>%
  ggplot(aes(!!sym(params_local$MLR_target), depth,
             col = data_source, fill=data_source)) +
  geom_path() +
  scale_y_reverse() +
  facet_grid( ~ basin_AIP)

```



# Write files

```{r write_csv}

full_join(dcant_zonal_bias %>% select(-c(mod, mod_truth)),
          dcant_pos_zonal_bias %>% select(-c(mod, mod_truth))) %>%
  write_csv(paste0(path_version_data, 
                   "dcant_zonal_bias.csv"))


if (surface_data) {
  bind_rows(
    dcant_zonal_bias_method_surface %>%
      mutate(method = "surface"),
    dcant_zonal_bias_method_deep %>%
      mutate(method = "deep")
  ) %>%
    write_csv(paste0(path_version_data,
                     "dcant_zonal_bias_method.csv"))
} else {
  dcant_zonal_bias_method_deep %>%
    mutate(method = "deep") %>%
    write_csv(paste0(path_version_data,
                     "dcant_zonal_bias_method.csv"))
  
}


```

