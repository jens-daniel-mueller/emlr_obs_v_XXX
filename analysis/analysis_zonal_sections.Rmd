---
title: "Analysis of dcant estimates"
author: "Jens Daniel MÃ¼ller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
params:
  Version_ID: "v_XXX"
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}

if (params$Version_ID == "v_XXX") {
  params_local <-
    read_rds(here::here("data/auxillary", "params_local.rds"))
  
} else {
  params_local <-
    read_rds(
      file = paste(path_root, "observations",
                   params$Version_ID,
                   "data/params_local.rds",
                   sep = "/")
    )
}

```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

path_version_figures  <-
  paste(path_observations,
        params_local$Version_ID,
        "/figures/",
        sep = "")
```

```{r load_libraries_specific, include = FALSE}
library(scales)
library(marelac)
library(kableExtra)
library(gt)
```

# Version ID

The results displayed on this site correspond to the Version_ID: `r params$Version_ID`

# Data sources

dcant estimates from this sensitivity case:

- Mean and SD per grid cell (lat, lon, depth)
- Zonal mean and SD (basin, lat, depth)
- Inventories (lat, lon)


```{r read_dcant_files}

dcant_zonal <-
  read_csv(paste(path_version_data,
                 "dcant_zonal.csv",
                 sep = ""))

dcant_zonal_mod_truth <-
  read_csv(paste(path_version_data,
                 "dcant_zonal_mod_truth.csv",
                 sep = ""))

dcant_zonal <- bind_rows(dcant_zonal,
                        dcant_zonal_mod_truth)

dcant_profile <-
  read_csv(paste(path_version_data,
                 "dcant_profile.csv",
                 sep = ""))

dcant_profile_mod_truth <-
  read_csv(paste(path_version_data,
                 "dcant_profile_mod_truth.csv",
                 sep = ""))

dcant_profile <- bind_rows(dcant_profile,
                        dcant_profile_mod_truth)

dcant_zonal_method <-
  read_csv(paste(path_version_data,
                 "dcant_zonal_method.csv",
                 sep = ""))

dcant_zonal_mod_truth_method <-
  read_csv(paste(path_version_data,
                 "dcant_zonal_mod_truth_method.csv",
                 sep = ""))


surface_data <- nrow(dcant_zonal_mod_truth_method %>% 
                       filter(method == "surface")) > 0

dcant_zonal_method <- bind_rows(dcant_zonal_method,
                        dcant_zonal_mod_truth_method)


```

# dcant - positive

In a first series of plots we explore the distribution of dcant, taking only positive estimates into account (positive here refers to the mean dcant estimate across MLR model predictions available for each grid cell). Negative values were set to zero before calculating mean sections and inventories.


```{r dcant_pos_zonal_mean_sections, fig.asp=0.6}

dcant_pos_zonal_bias <- dcant_zonal %>%
  filter(data_source %in% c("mod", "mod_truth")) %>%
  select(lat, depth, basin_AIP, data_source, dcant_pos) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant_pos) %>%
  mutate(dcant_pos_bias = mod - mod_truth)

dcant_pos_zonal_bias <- full_join(
  dcant_pos_zonal_bias,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)


for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  for (i_data_source in unique(dcant_zonal$data_source)) {
    # i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]
    # i_data_source <- unique(dcant_zonal$data_source)[1]
    
    print(
      p_section_zonal(
        df = dcant_zonal %>%
          filter(basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant_pos",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source)
      )
    )
    
  }
  print(
    p_section_zonal(
      df = dcant_pos_zonal_bias %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_pos_bias",
      col = "divergent",
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
}

```


# dcant - all

In a second series of plots we explore the distribution of all dcant, taking positive and negative estimates into account.

```{r dcant_all_zonal_mean_sections, fig.asp=0.6}

dcant_zonal_bias <- dcant_zonal %>%
  filter(data_source %in% c("mod", "mod_truth")) %>%
  select(lat, depth, basin_AIP, data_source, dcant) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant) %>%
  mutate(dcant_bias = mod - mod_truth)

dcant_zonal_bias <- full_join(
  dcant_zonal_bias,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)

# i_data_source <- unique(dcant_zonal$data_source)[1]
# i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]

for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  for (i_data_source in unique(dcant_zonal$data_source)) {
    print(
      p_section_zonal(
        df = dcant_zonal %>%
          filter(basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant",
        gamma = "gamma_mean",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source))
    )
    
  }
  
    print(
    p_section_zonal(
      df = dcant_zonal_bias %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_bias",
      col="divergent",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
  
}
  
```

## Profiles


```{r dcant_profiles}

dcant_profile %>%
  ggplot(aes(dcant, depth,
             col = data_source, fill=data_source)) +
  geom_vline(xintercept = 0) +
  geom_ribbon(aes(xmin = dcant - dcant_sd,
                  xmax = dcant + dcant_sd),
              alpha = 0.2,
              col = "transparent") +
  geom_path() +
  scale_y_reverse() +
  facet_grid( ~ basin_AIP)

```



## Surface


```{r dcant_all_zonal_mean_sections_surface, fig.asp=0.6, eval=surface_data}

dcant_zonal_bias_method_surface <- dcant_zonal_method %>%
  filter(data_source %in% c("mod", "mod_truth"),
         method == "surface") %>%
  select(lat, depth, basin_AIP, data_source, dcant) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant) %>%
  mutate(dcant_bias = mod - mod_truth)

dcant_zonal_bias_method_surface <- full_join(
  dcant_zonal_bias_method_surface,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)

# i_data_source <- unique(dcant_zonal$data_source)[1]
# i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]

for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  for (i_data_source in unique(dcant_zonal$data_source)) {
    print(
      p_section_zonal(
        df = dcant_zonal_method %>%
          filter(method == "surface",
                 basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant",
        plot_slabs = "n",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source))
    )
    
  }
  
    print(
    p_section_zonal(
      df = dcant_zonal_bias_method_surface %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_bias",
      col="divergent",
      plot_slabs = "n",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
  
}
  
```

## Deep


```{r dcant_all_zonal_mean_sections_deep, fig.asp=0.6}

dcant_zonal_bias_method_deep <- dcant_zonal_method %>%
  filter(data_source %in% c("mod", "mod_truth"),
         method == "eMLR") %>%
  select(lat, depth, basin_AIP, data_source, dcant) %>%
  pivot_wider(names_from = data_source,
              values_from = dcant) %>%
  mutate(dcant_bias = mod - mod_truth)

dcant_zonal_bias_method_deep <- full_join(
  dcant_zonal_bias_method_deep,
  dcant_zonal_mod_truth %>% select(lat, depth, basin_AIP, gamma_mean)
)

# i_data_source <- unique(dcant_zonal$data_source)[1]
# i_basin_AIP <- unique(dcant_zonal$basin_AIP)[1]

for (i_basin_AIP in unique(dcant_zonal$basin_AIP)) {
  for (i_data_source in unique(dcant_zonal$data_source)) {
    print(
      p_section_zonal(
        df = dcant_zonal_method %>%
          filter(method == "eMLR",
                 basin_AIP == i_basin_AIP,
                 data_source == i_data_source),
        var = "dcant",
        subtitle_text =
          paste("Basin:", i_basin_AIP, "| data_source:", i_data_source))
    )
    
  }
  
    print(
    p_section_zonal(
      df = dcant_zonal_bias_method_deep %>%
        filter(basin_AIP == i_basin_AIP),
      var = "dcant_bias",
      col="divergent",
      breaks = params_global$breaks_dcant_offset,
      subtitle_text =
        paste("Basin:", i_basin_AIP, "| data_source: mod - mod_truth")
    )
  )
  
}
  
```


# Write files

```{r write_csv}

full_join(dcant_zonal_bias %>% select(-c(mod, mod_truth)),
          dcant_pos_zonal_bias %>% select(-c(mod, mod_truth))) %>%
  write_csv(paste0(path_version_data, 
                   "dcant_zonal_bias.csv"))


if (surface_data) {
  bind_rows(
    dcant_zonal_bias_method_surface %>%
      mutate(method = "surface"),
    dcant_zonal_bias_method_deep %>%
      mutate(method = "deep")
  ) %>%
    write_csv(paste0(path_version_data,
                     "dcant_zonal_bias_method.csv"))
} else {
  dcant_zonal_bias_method_deep %>%
    mutate(method = "deep") %>%
    write_csv(paste0(path_version_data,
                     "dcant_zonal_bias_method.csv"))
  
}


```

