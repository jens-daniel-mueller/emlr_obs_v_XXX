---
title: "Mapping dcant eMLR"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
params:
  Version_ID: "v_XXX"
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup_obs.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}

if (params$Version_ID == "v_XXX") {
  params_local <-
    read_rds(here::here("data/auxillary", "params_local.rds"))
  
} else {
  params_local <-
    read_rds(
      file = paste(path_root, "observations",
                   params$Version_ID,
                   "data/params_local.rds",
                   sep = "/")
    )
}


```

```{r define_paths, include = FALSE}

# only path_observations needs to be changed to model
path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

path_version_figures  <-
  paste(path_observations,
        params_local$Version_ID,
        "/figures/",
        sep = "")

path_model_preprocessing    <-
  paste(path_root, "/model/preprocessing/", sep = "")
```

```{r load_libraries_specific, include=FALSE}
library(seacarb)
library(marelac)
library(broom)

```

# Version ID

The results displayed on this site correspond to the Version_ID: `r params$Version_ID`

# Required data

## Predictor fields

Currently, we use following combined predictor fields:

- WOA18: S, T, and derived variables
- GLODAP16: Oxygen, PO4, NO3, Silicate, and derived variables

```{r read_predictor_files}

predictors <-
  read_csv(paste(path_version_data,
                 "W18_st_G16_opsn.csv",
                 sep = ""))

predictors_surface <-
  read_csv(paste(path_version_data,
                 "W18_st_G16_opsn_surface.csv",
                 sep = ""))

# check if surface data exist
surface_data <- nrow(predictors_surface) > 0

tref  <-
  read_csv(paste(path_version_data,
                 "tref.csv",
                 sep = ""))


variables <-
  c("dissicos", "talkos", "po4os", "spco2", "tos", "sos")

for (i_variable in variables) {
  
  temp <- read_csv(paste0(
    path_root,
    "/model/preprocessing/surface_ocean_A/", i_variable, ".csv")
  )
  
  if (exists("surface_mod")) {
    surface_mod <- full_join(surface_mod, temp)
  }
  
  if (!exists("surface_mod")) {
    surface_mod <- temp
  }
}

rm(temp, i_variable, variables)

surface_obs <- read_csv(paste0(
    path_observations,
    "preprocessing/OceanSODA.csv")
  )

```

## Atm. pCO2

Required only to estimate the change of dcant in surface water and assuming that the ocean pCO2 trend follows the atmospheric forcing.

```{r read_atm_pCO2}

co2_atm <-
  read_csv(paste(path_preprocessing,
                 "co2_atm.csv",
                 sep = ""))

co2_atm_tref <-
  read_csv(paste(path_version_data,
                 "co2_atm_tref.csv",
                 sep = ""))

disequi_pCO2_tref <-
  read_csv(paste(path_version_data,
                 "disequi_pCO2_tref.csv",
                 sep = ""))

```

## MLR models

```{r load_eMLR_models}

lm_best_dcant <-
  read_csv(paste(path_version_data,
                 "lm_best_dcant.csv",
                 sep = ""))
```

## Model truth

```{r read_surface_model_truth_dcant}

tcant_tref_1 <-
  read_csv(
    paste(
      path_model_preprocessing,
      "cant_annual_field_AD",
      "/cant_",
      unique(tref$median_year[1]),
      ".csv",
      sep = ""
    )
  )

tcant_tref_1 <- tcant_tref_1 %>%
  rename(tcant_tref_1 = cant_total) %>%
  select(-year)

tcant_tref_2 <-
  read_csv(
    paste(
      path_model_preprocessing,
      "cant_annual_field_AD",
      "/cant_",
      unique(tref$median_year[2]),
      ".csv",
      sep = ""
    )
  )

tcant_tref_2 <- tcant_tref_2 %>%
  rename(tcant_tref_2 = cant_total) %>%
  select(-year)

dcant_3d <- left_join(tcant_tref_1, tcant_tref_2) %>%
  mutate(dcant = tcant_tref_2 - tcant_tref_1)

rm(tcant_tref_1, tcant_tref_2)

dcant_3d <- dcant_3d %>%
  mutate(dcant_pos = if_else(dcant <= 0, 0, dcant))

dcant_surface_mod_truth <- dcant_3d %>% 
  filter(depth == 5)

rm(dcant_3d)

```




# Join MLRs + climatologies

```{r merge_model_coeff_predictor_climatology}

# remove predictor variable from model
lm_best_dcant <- lm_best_dcant %>% 
  mutate(model = str_remove(model, paste(params_local$MLR_target, "~ ")))

# join predictors and MLR
dcant <- left_join(lm_best_dcant, predictors)

rm(predictors, lm_best_dcant)

```

# Map dcant

## Deep water

### Apply MLRs to predictor

```{r calculate_cant}

dcant <- b_dcant(dcant)

```


### Sections by model

Zonal section plots are produced for every 20° longitude, each era and for all models individually. Plots can be accessed here:  

- `r paste(path_version_figures, "Cant_model_sections/", sep = "")`

```{r cant_section_by_model_eras_lon}


if (params_local$plot_all_figures == "y") {
  for (i_eras in unique(cant$eras)) {
    # i_eras <- unique(cant$eras)[2]
    cant_eras <- cant %>%
      filter(eras == i_eras)
    
    for (i_lon in params_global$longitude_sections_regular) {
      # i_lon <- params_global$longitude_sections_regular[7]
      cant_eras_lon <- cant_eras %>%
        filter(lon == i_lon)
      
      limits = max(abs(cant_eras_lon$cant)) * c(-1, 1)
      
      cant_eras_lon %>%
        ggplot(aes(lat, depth, z = cant)) +
        stat_summary_2d(
          fun = "mean",
          na.rm = TRUE,
          bins = 20,
          col = "grey"
        ) +
        scale_fill_scico(name = "Cant",
                         palette = "vik",
                         limit = limits) +
        scale_y_reverse(limits = c(params_global$plotting_depth, NA)) +
        scale_x_continuous(limits = c(-85, 85)) +
        labs(title = paste(
          "eras:",
          i_eras,
          "| lon:",
          i_lon,
          "|",
          params_local$Version_ID
        )) +
        facet_wrap(~ model, ncol = 5)
      
      ggsave(
        paste(
          path_version_figures,
          "Cant_model_sections/",
          paste("Cant_model",
                i_eras,
                "lon",
                i_lon,
                "section.png",
                sep = "_"),
          sep = ""
        ),
        width = 17,
        height = 9
      )
      
    }
  }
}

```


## Surface water

As outlined in Gruber et al. (2019), a transient equilibrium approach was applied to estimate dcant in surface waters, assuming that the CO~2~ system in these waters has followed the increase in atmospheric CO~2~ closely. 

Using eq 10.2.16 from OBD, the change in anthropogenic CO~2~ in the upper ocean was computed as:

$\Delta$~t~C~ant,eq~(t2 − t1) = 1∕$\gamma$ ⋅ DIC/pCO~2~ ⋅ (pCO~2,atm~ (t2)− pCO~2,atm~(t1))

, where DIC and pCO~2~ are the in situ values, where $\gamma$ is the buffer (Revelle) factor and where we evaluated the right-hand side using seacarb employing the Luecker constants using the climatological values for temperature, salinity, DIC and Alk.

### Layer depth

```{r surface_layer_depth, eval=surface_data}

surface_layer <- predictors_surface %>% 
  group_by(lat, lon, data_source) %>% 
  summarise(depth_max = max(depth),
            n_layer = n()) %>% 
  ungroup()


map +
  geom_raster(data = surface_layer,
              aes(lon, lat, fill=depth_max)) +
  scale_fill_scico(palette = "nuuk", direction = -1) +
  facet_grid(data_source ~ .)


map +
  geom_raster(data = surface_layer,
              aes(lon, lat, fill=n_layer)) +
  scale_fill_scico(palette = "tokyo") +
  facet_grid(data_source ~ .)

```


### Surface pCO2

```{r calc_surface_pCO2, eval=surface_data}

predictors_surface_all_depth <- predictors_surface

predictors_surface <- predictors_surface %>%
  filter(depth %in% c(0, 5)) %>%
  mutate(
    pCO2 = carb(
      flag = 15,
      var1 = TAlk * 1e-6,
      var2 = TCO2 * 1e-6,
      S = sal,
      T = temp,
      P = depth / 10,
      Pt = phosphate * 1e-6,
      Sit = silicate * 1e-6,
      k1k2 = "l"
    )$pCO2
  )

```

```{r pCO2_climatology_map, fig.asp=0.6, eval=surface_data}

predictors_surface %>%
  mutate(depth = 0) %>% 
  group_split(data_source) %>%
  # head(1) %>%
  map( ~
         p_map_climatology(
           df = .x,
           var = "pCO2",
           subtitle_text = paste("Data source: ", unique(.x$data_source))
         ))

```



### Revelle factor

Plots below show the calculated climatological Revelle factor values.

```{r calc_revelle_factor_climatology, eval=surface_data}

predictors_surface <- predictors_surface %>%
  mutate(
    rev_fac = buffer(
      flag = 15,
      var1 = TAlk * 1e-6,
      var2 = TCO2 * 1e-6,
      S = sal,
      T = temp,
      P = depth / 10,
      Pt = phosphate * 1e-6,
      Sit = silicate * 1e-6,
      k1k2 = "l"
    )$BetaD
  )


```


```{r revelle_factor_climatology_map, fig.asp=0.6, eval=surface_data}

predictors_surface %>%
  group_split(data_source) %>%
  # head(1) %>%
  map( ~
         p_map_climatology(
           df = .x,
           var = "rev_fac",
           subtitle_text = paste("Data source: ", unique(.x$data_source))
         ))

```


```{r revelle_factor_climatology_sections, fig.asp=1, eval=FALSE}

predictors_surface %>%
  group_split(data_source) %>%
  # head(1) %>%
  map( ~
         p_section_climatology_regular(
           df = .x,
           var = "rev_fac",
           surface = "y",
           subtitle_text = paste("Data source: ", unique(.x$data_source))
         ))

```


### dcant calculation

```{r calc_dcant_surface, eval=surface_data}

# calculate increase in atm pCO2 between eras
co2_atm_tref <- co2_atm_tref %>%
  arrange(pCO2_tref) %>%
  mutate(d_pCO2_tref = pCO2_tref - lag(pCO2_tref)) %>%
  drop_na() %>%
  select(d_pCO2_tref)

co2_atm_tref_change <- co2_atm_tref

dcant_surface <- full_join(predictors_surface, co2_atm_tref,
                           by = character())

# calculate cant
dcant_surface <- dcant_surface %>%
  mutate(dcant = (1 / rev_fac) *
           (TCO2 / pCO2) * d_pCO2_tref)

surface_rev_fac <- dcant_surface

# calculate positive cant
dcant_surface <- dcant_surface %>%
  mutate(dcant_pos = if_else(dcant < 0, 0, dcant)) %>% 
  select(lon, lat, data_source, dcant, dcant_pos)


dcant_surface <- full_join(
  dcant_surface,
  predictors_surface_all_depth
)

```

```{r calc_dcant_surface_disequi, eval=surface_data}

# extract disequilibrium change of pCO2
disequi_pCO2_tref <- disequi_pCO2_tref %>% 
  arrange(era) %>% 
  group_by(data_source) %>% 
  mutate(delta_disequi_pco2 = mean_delta_pCO2 - lag(mean_delta_pCO2)) %>% 
  ungroup() %>% 
  drop_na() %>% 
  select(data_source, delta_disequi_pco2)

# calculate increase in atm pCO2 between eras
co2_atm_tref <- expand_grid(
  co2_atm_tref,
  disequi_pCO2_tref
  )

co2_atm_tref <- co2_atm_tref %>% 
  mutate(d_pCO2_tref_disequi = d_pCO2_tref + delta_disequi_pco2) %>% 
  select(data_source, d_pCO2_tref_disequi)

dcant_surface_disequi <- full_join(predictors_surface, co2_atm_tref)

# calculate cant
dcant_surface_disequi <- dcant_surface_disequi %>%
  mutate(dcant = (1 / rev_fac) *
           (TCO2 / pCO2) * d_pCO2_tref_disequi)

surface_rev_fac_disequi <- dcant_surface_disequi

# calculate positive cant
dcant_surface_disequi <- dcant_surface_disequi %>%
  mutate(dcant_pos = if_else(dcant < 0, 0, dcant)) %>%
  select(lon, lat, data_source, dcant, dcant_pos)


dcant_surface_disequi <- full_join(dcant_surface_disequi,
                                   predictors_surface_all_depth)

```

### Sea surface observations

```{r prepare_surface_data, eval=surface_data}


# harmonize variable naming and formatting
surface_mod <- surface_mod %>% 
  rename(tco2 = dissicos,
         talk = talkos,
         phosphate = po4os,
         pco2 = spco2,
         temp = tos,
         sal = sos) %>% 
  mutate(tco2 = tco2 * 1e3,
         phosphate = phosphate * 1e3) %>% 
  mutate(cstar = b_cstar_phosphate(tco2 = tco2,
                                   phosphate = phosphate,
                                   talk = talk),
         cstar_phosphate = - params_local$rCP * phosphate,
         cstar_talk = - 0.5 * (talk - (params_local$rNP * phosphate)))


surface_obs <- surface_obs %>% 
  select(lon, lat, year, temp, tco2, talk, pco2 = pCO2)

# combine model and observation-based data
surface <- bind_rows(
  surface_mod %>% mutate(data_source = "mod") %>% drop_na(),
  surface_obs %>% mutate(data_source = "obs") %>% drop_na()
)

```

```{r calc_long_term_tco2_trends}

surface_tco2_regression_fit <- 
  full_join(surface, co2_atm %>% rename(pco2_atm = pCO2)) %>% 
  filter(year >= 1990) %>% 
  select(data_source, lon, lat, pco2_atm, tco2) %>% 
  drop_na() %>% 
  group_by(data_source, lon, lat) %>% 
  nest()

surface_tco2_regression_fit <- surface_tco2_regression_fit %>%
  mutate(
    fit = map(data,
              ~ lm(tco2 ~ pco2_atm, data = .x)),
    tidied = map(fit, tidy)
    # glanced = map(fit, glance)
    # augmented = map(fit, augment)
  )

# extract tidy model output (model coefficients)
surface_tco2_regression_tidy <-surface_tco2_regression_fit %>%
  select(-c(data, fit)) %>%
  unnest(tidied) %>% 
  filter(term == "pco2_atm") %>% 
  rename(slope = estimate)

surface_tco2_regression_tidy %>% 
  ggplot(aes(slope)) +
  geom_histogram()

surface_tco2_regression_tidy <- surface_tco2_regression_tidy %>% 
  filter(slope > -1,
         slope < 2)

map +
  geom_raster(data = surface_tco2_regression_tidy,
              aes(lon, lat, fill = slope)) +
  facet_grid(.~ data_source) +
  scale_fill_divergent()

map +
  geom_raster(data = surface_tco2_regression_tidy %>% filter(slope > 0),
              aes(lon, lat, fill = slope)) +
  facet_grid(.~ data_source) +
  scale_fill_viridis_c()

map +
  geom_raster(data = surface_tco2_regression_tidy,
              aes(lon, lat, fill = p.value)) +
  facet_grid(.~ data_source) +
  scale_fill_viridis_c()

map +
  geom_raster(data = surface_tco2_regression_tidy,
              aes(lon, lat, fill = std.error)) +
  facet_grid(.~ data_source) +
  scale_fill_viridis_c()

rm(surface_tco2_regression_fit)

surface_tco2_regression_tidy <- surface_tco2_regression_tidy %>% 
  select(data_source, lat, lon, slope)

d_co2_atm <- co2_atm_tref_change %>% pull(d_pCO2_tref)

surface_tco2_regression_tidy <- surface_tco2_regression_tidy %>% 
  mutate(d_tco2 = slope * d_co2_atm)

map +
  geom_raster(data = surface_tco2_regression_tidy %>% filter(slope > 0),
              aes(lon, lat, fill = d_tco2)) +
  facet_grid(.~ data_source) +
  scale_fill_viridis_c()

```

```{r calc_dcant_surface_based_on_surface_observations, fig.asp=1, eval=surface_data}

# combine with era definition
surface <- expand_grid(surface, tref)

# determine era averages
surface <- surface %>%
  filter(year >= start & year <= end) %>% 
  select(-c(start, end, year, era))

surface <- surface %>% 
  group_by(lon, lat, median_year, data_source) %>% 
  summarise(across(where(is.numeric), ~ mean(.x, na.rm = TRUE))) %>% 
  ungroup()

# produce wide format
surface_wide <- surface %>% 
  pivot_longer(tco2:cstar_talk,
               names_to = "parameter",
               values_to = "value") %>% 
  pivot_wider(names_from = median_year,
              values_from = value)

# calculate decadel changed
surface_wide <- surface_wide %>% 
  mutate(d = !!sym(as.character(sort(tref$median_year)[2])) -
           !!sym(as.character(sort(tref$median_year)[1])))


# plot decadel trends
surface_trend <- surface_wide %>% 
  select(lon, lat, parameter, data_source, d)

surface_trend %>%
  group_by(parameter) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ map +
      geom_raster(data = .x,
                  aes(lon, lat, fill = d)) +
      scale_fill_divergent(name = unique(.x$parameter)) +
      facet_grid(data_source~.) +
      labs(title = paste("Decadel change:", tref$era[1], "to", tref$era[2]))
  )

surface_pco2 <- surface_trend %>% 
  filter(parameter == "pco2") %>% 
  select(lat, lon, data_source, d_pco2_era = d)

surface_pco2 <- full_join(
  surface_pco2,
  surface_rev_fac %>% 
    select(lon, lat, data_source, rev_fac, TCO2, pCO2)
)

# calculate dcant
surface_pco2 <- surface_pco2 %>%
  mutate(dcant_pco2 = (1 / rev_fac) *
           (TCO2 / pCO2) * d_pco2_era) %>% 
  drop_na()


```

### Control plots

```{r dcant_surface_climatology_map, fig.asp=0.6, eval=surface_data}

dcant_surface_disequi %>%
  group_split(data_source) %>%
  # head(1) %>%
  map( ~
         p_map_climatology(
           df = .x,
           var = "dcant",
           subtitle_text = paste("Data source: ", unique(.x$data_source))
         ))

```


```{r dcant_surface_climatology_sections, fig.asp=1, eval=surface_data}

dcant_surface_disequi %>%
  group_split(data_source) %>%
  # head(1) %>%
  map( ~
         p_section_climatology_regular(
           df = .x,
           var = "dcant",
           surface = "y",
           subtitle_text = paste("Data source: ", unique(.x$data_source))
         ))


```

### Surf, equi, truth

```{r surf_equi_truth, fig.asp=1.5}

surface_dcant_comparison <- bind_rows(
  surface_trend %>%
    filter(data_source == "mod",
           parameter == "cstar") %>%
    select(lon, lat, dcant = d) %>%
    mutate(data_source = "cstar"),
  # surface_trend %>%
  #   filter(data_source == "mod",
  #          parameter == "cstar_talk") %>%
  #   select(lon, lat, dcant = d) %>%
  #   mutate(data_source = "cstar_talk"),
  # surface_trend %>%
  #   filter(data_source == "mod",
  #          parameter == "cstar_phosphate") %>%
  #   select(lon, lat, dcant = d) %>%
  #   mutate(data_source = "cstar_phosphate"),
  surface_trend %>%
    filter(data_source == "mod",
           parameter == "tco2") %>%
    select(lon, lat, dcant = d) %>%
    mutate(data_source = "tco2"),
  dcant_surface %>%
    filter(data_source == "mod",
           depth == 5) %>%
    select(lon, lat, dcant) %>%
    mutate(data_source = "atm_equi"),
  dcant_surface_disequi %>%
    filter(data_source == "mod",
           depth == 5) %>%
    select(lon, lat, dcant) %>%
    mutate(data_source = "atm_disequi"),
  surface_pco2 %>%
    filter(data_source == "mod") %>%
    select(lon, lat, dcant = dcant_pco2) %>%
    mutate(data_source = "spco2"),
  surface_tco2_regression_tidy %>%
    filter(data_source == "mod") %>%
    select(lon, lat, dcant = d_tco2) %>%
    mutate(data_source = "tco2_regression"),
  dcant_surface_mod_truth %>%
    select(lon, lat, dcant) %>%
    mutate(data_source = "mod_truth")
)

p_map_dcant_slab(df = surface_dcant_comparison,
                  var = "dcant",
                 title_text = "Sea surface maps") +
  facet_grid(data_source ~ .)


```


```{r surf_equi_truth_bias, fig.asp=1.3}

surface_dcant_comparison_bias <- surface_dcant_comparison %>% 
  pivot_wider(names_from = data_source,
              values_from = dcant) %>% 
  mutate(cstar_bias = cstar - mod_truth,
         tco2_bias = tco2 - mod_truth,
         atm_equi_bias = atm_equi - mod_truth,
         atm_disequi_bias = atm_disequi - mod_truth,
         spco2_bias = spco2 - mod_truth,
         tco2_regression_bias = tco2_regression - mod_truth) %>% 
  select(lon, lat, cstar_bias:tco2_regression_bias) %>% 
  pivot_longer(cstar_bias:tco2_regression_bias,
               names_to = "data_source",
               values_to = "dcant_bias")

p_map_dcant_slab(df = surface_dcant_comparison_bias,
                  var = "dcant_bias",
                 col = "bias",
                 title_text = "Sea surface maps") +
  facet_grid(data_source ~ .)

```


## Average model dcant

Mean and sd are calculated across `r params_local$MLR_number` models for Cant in each grid cell (XYZ), basin and era combination. Calculations are performed for all cant values vs positive values only.

### Deep water averaging

```{r calc_dcant_model_mean}

dcant_average <- m_dcant_3d_average(dcant)
dcant_average <- m_cut_gamma(dcant_average, "gamma")

# split data set for individual predictor contributions and total cant
dcant_predictor_3d <- dcant_average %>% 
  select(-c("dcant", "dcant_pos", ends_with("_sd")))

dcant_average <- dcant_average %>%
  select(
    lon,
    lat,
    depth,
    basin_AIP,
    data_source,
    dcant,
    dcant_pos,
    dcant_sd,
    dcant_pos_sd,
    gamma,
    gamma_sd,
    gamma_slab
  )

```


```{r cant_deep_climatology_map, fig.asp=0.6}

dcant_average %>%
  group_split(data_source) %>%
  # head(1) %>% 
  map(~ p_map_climatology(
    df = .x,
    var = "dcant_pos",
    subtitle_text = paste("data_source:", unique(.x$data_source))
  ))


```


```{r dcant_deep_climatology_sections, fig.asp=1}

dcant_average %>%
  group_split(data_source) %>%
  # head(1) %>% 
  map(~ p_section_climatology_regular(
    df = .x,
    surface = "n",
    var = "dcant_pos",
    subtitle_text = paste("data_source:", unique(.x$data_source))
  ))

```



### Surface water averaging

The averaging function is also applied to the surface data, although only one value per grid cell was mapped, to ensure consistency with the deep water values.

```{r calc_dcant_mean_surface, eval=surface_data}

dcant_surface_average <-
  m_dcant_3d_average(dcant_surface_disequi)

dcant_surface_average <- m_cut_gamma(dcant_surface_average, "gamma")
rm(dcant_surface)

```


## Join surface and deep water

```{r join_surface_deep_dcant}

if (surface_data) {
  dcant_3d <-
  full_join(
    dcant_average %>% mutate(method = "eMLR"),
    dcant_surface_average %>%  mutate(method = "surface")
  )
} else {
  dcant_3d <- dcant_average %>% mutate(method = "eMLR")
}



rm(dcant_surface_average, dcant_average)

```


## Zonal sections

For each basin and era combination, the zonal mean dcant is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r calc_cant_zonal_mean_sections}

dcant_zonal <- dcant_3d %>%
  group_by(data_source) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(zonal)

dcant_zonal <- m_cut_gamma(dcant_zonal,
                           "gamma_mean")

dcant_zonal_method <- dcant_3d %>%
  group_by(data_source, method) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(zonal)

dcant_zonal_method <- m_cut_gamma(dcant_zonal_method,
                                   "gamma_mean")

dcant_zonal <- dcant_zonal %>% 
  rename(dcant = dcant_mean,
         dcant_pos = dcant_pos_mean) %>% 
  select(-c(dcant_sd_sd, dcant_pos_sd_sd,
            gamma_sd_mean, gamma_sd_sd))

dcant_zonal_method <- dcant_zonal_method %>% 
  rename(dcant = dcant_mean,
         dcant_pos = dcant_pos_mean) %>% 
  select(-c(dcant_sd_sd, dcant_pos_sd_sd,
            gamma_sd_mean, gamma_sd_sd))

```


## Profiles

For each basin, the mean (+ min and max) dcant profile is calculated, again for all vs positive only values. Likewise, sd is calculated for the averaging of the mean basin fields.

```{r calc_cant_profiles}

dcant_profile <- dcant_3d %>%
  mutate(area = earth_surf(lat, lon),
         dcant_scaled = dcant * area) %>% 
  group_by(data_source, basin_AIP, depth) %>% 
  summarise(dcant_sd = sqrt(
              Hmisc::wtd.var(dcant, area, na.rm = TRUE)),
            dcant = sum(dcant_scaled) / sum(area)) %>% 
  ungroup()

```

## Mean dcant sections by coefficient

For each basin and era combination, the zonal mean is calculated for the term of each predictor.

```{r calc_cant_predictor_mean_sections}

dcant_predictor_zonal <- dcant_predictor_3d %>%
  group_by(data_source) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd(.x))) %>%
  select(-data) %>%
  unnest(zonal)

dcant_predictor_zonal <-
  m_cut_gamma(dcant_predictor_zonal, "gamma_mean")

```

## Inventory calculation

To calculate dcant column inventories, we:  

1. Convert dcant concentrations to volumetric units
2. Multiply layer thickness with volumetric dcant concentration to get a layer inventory
3. For each horizontal grid cell and era, sum dcant layer inventories for different inventory depths (`r params_global$inventory_depths` m)

Step 2 is performed separately for all dcant and positive dcant values only.

### Full water column

```{r cant_inventories, fig.asp=1}

dcant_inv <- dcant_3d %>%
  group_by(data_source) %>%
  nest() %>%
  mutate(inv = map(.x = data, ~m_dcant_inv(.x))) %>%
  select(-data) %>%
  unnest(inv)

p_map_cant_inv(df = dcant_inv,
               var = "dcant_pos",
               subtitle_text = "for predefined integration depths") +
  facet_grid(inv_depth ~ data_source)

if (surface_data == FALSE){
  dcant_inv <- dcant_inv %>% 
    mutate(method = "total")
}


```

### Surface layer

```{r cant_inventories_surface, eval=surface_data}

dcant_inv_surface <- dcant_3d %>%
  filter(method == "surface") %>% 
  group_by(data_source) %>%
  nest() %>%
  mutate(inv = map(.x = data, ~m_dcant_inv(.x))) %>%
  select(-data) %>%
  unnest(inv)

p_map_cant_inv(df = dcant_inv_surface %>% 
                 filter(inv_depth < 1000),
               var = "dcant_pos",
               subtitle_text = "for predefined integration depths",
               breaks = c(-Inf,seq(0,4,0.5), Inf)) +
  facet_grid(inv_depth ~ data_source)


```

### eMLR only

```{r combine_dcant_inventories, eval=surface_data}

dcant_inv <- full_join(
  dcant_inv %>% rename(dcant_total = dcant,
                       dcant_pos_total = dcant_pos),
  dcant_inv_surface %>% rename(dcant_surface = dcant,
                               dcant_pos_surface = dcant_pos)
)

dcant_inv <- dcant_inv %>%
  mutate(dcant_eMLR = dcant_total -
           replace(dcant_surface, is.na(dcant_surface), 0),
         dcant_pos_eMLR = dcant_pos_total -
           replace(dcant_pos_surface, is.na(dcant_pos_surface), 0))

dcant_inv_all <- dcant_inv %>% 
  select(-starts_with("dcant_pos")) %>% 
  pivot_longer(starts_with("dcant_"),
               names_to = "method",
               names_prefix = "dcant_",
               values_to = "dcant")

dcant_inv_pos <- dcant_inv %>% 
  select(data_source, lon, lat, basin_AIP, inv_depth,
         starts_with("dcant_pos_")) %>% 
  pivot_longer(starts_with("dcant_pos_"),
               names_to = "method",
               names_prefix = "dcant_pos_",
               values_to = "dcant_pos")

dcant_inv <- full_join(
  dcant_inv_all,
  dcant_inv_pos
)

rm(dcant_inv_all, dcant_inv_pos, dcant_inv_surface)

dcant_inv %>%
  group_by(inv_depth) %>%
  group_split() %>% 
  # tail(1) %>%
  map(
    ~ p_map_cant_inv(df = .x,
                     var = "dcant",
                     subtitle_text = paste("Integration depth",
                                           unique(.x$inv_depth))) +
      facet_grid(method ~ data_source)
  )

```


## Budgets

Global dcant budgets were estimated in units of Pg C. Please note that here we added dcant (all vs postitive only) values and do not apply additional corrections for areas not covered.

```{r budget_global}

dcant_budget_global <- m_dcant_budget(dcant_inv)

dcant_budget_global %>%
  filter(inv_depth == params_global$inventory_depth_standard,
         method == "total") %>%
  ggplot(aes(estimate, value)) +
  scale_fill_brewer(palette = "Dark2") +
  geom_col() +
  facet_grid(~data_source)

```

```{r budget_global_surface, eval=surface_data}

dcant_budget_global %>%
  filter(inv_depth == params_global$inventory_depth_standard,
         method %in% c("surface", "eMLR")) %>%
  ggplot(aes(estimate, value, fill=method)) +
  scale_fill_brewer(palette = "Dark2") +
  geom_col() +
  facet_grid(.~data_source)

```


```{r budget_basin_AIP}

dcant_budget_basin_AIP <- dcant_inv %>% 
  group_by(basin_AIP) %>%
  nest() %>% 
  mutate(budget = map(.x = data, ~m_dcant_budget(.x))) %>% 
  select(-data) %>%
  unnest(budget)

```

```{r budget_basin_AIP_fig, eval=surface_data}

dcant_budget_basin_AIP %>%
  filter(inv_depth == params_global$inventory_depth_standard,
         method %in% c("surface", "eMLR")) %>%
  ggplot(aes(basin_AIP, value, fill=method)) +
  scale_fill_brewer(palette = "Dark2") +
  geom_col() +
  facet_grid(estimate~data_source)

```


```{r budget_MLR_regions}

dcant_budget_basin_MLR <-
  full_join(dcant_inv, basinmask) %>%
  group_by(basin, MLR_basins) %>%
  nest() %>%
  mutate(budget = map(.x = data, ~ m_dcant_budget(.x))) %>%
  select(-data) %>%
  unnest(budget)

```


```{r budget_MLR_regions_fig, fig.asp=1, eval=surface_data}

dcant_budget_basin_MLR %>%
  filter(inv_depth == params_global$inventory_depth_standard,
         method %in% c("surface", "eMLR")) %>%
  group_by(MLR_basins) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ ggplot(data = .x,
             aes(basin, value, fill = method)) +
      scale_fill_brewer(palette = "Dark2") +
      geom_col() +
      facet_grid(estimate ~ data_source) +
      labs(title = paste("MLR_basins:", unique(.x$MLR_basins)))
  )

```


```{r budget_lat_grid, fig.asp=1}

dcant_budget_lat_grid <- 
  dcant_inv %>% 
  m_grid_horizontal_coarse() %>%
  group_by(lat_grid, basin_AIP) %>% 
  nest() %>%
  mutate(budget = map(.x = data, ~ m_dcant_budget(.x))) %>%
  select(-data) %>%
  unnest(budget)

```

```{r budget_lat_grid_fig, fig.asp=1, eval=surface_data}

dcant_budget_lat_grid %>%
  filter(inv_depth == params_global$inventory_depth_standard,
         method %in% c("surface", "eMLR")) %>%
  group_by(basin_AIP) %>%
  group_split() %>%
  # head(1) %>%
  map(
    ~ ggplot(data = .x,
             aes(lat_grid, value, fill = method)) +
      scale_fill_brewer(palette = "Dark2") +
      geom_col() +
      coord_flip() +
      facet_grid(estimate ~ data_source) +
      labs(title = paste("MLR_basins:", unique(.x$basin_AIP)))
  )

```



# Write csv

```{r write_cant_files}

dcant_3d %>%
  write_csv(paste(path_version_data,
                  "dcant_3d.csv", sep = ""))

dcant_predictor_3d %>%
  write_csv(paste(path_version_data,
                  "dcant_predictor_3d.csv", sep = ""))

dcant_zonal %>%
  write_csv(paste(path_version_data,
                  "dcant_zonal.csv", sep = ""))

dcant_profile %>%
  write_csv(paste(path_version_data,
                  "dcant_profile.csv", sep = ""))

dcant_zonal_method %>%
  write_csv(paste(path_version_data,
                  "dcant_zonal_method.csv", sep = ""))

dcant_predictor_zonal %>%
  write_csv(paste(path_version_data,
                  "dcant_predictor_zonal.csv", sep = ""))

dcant_inv %>%
  filter(method == "total") %>% 
  select(-method) %>% 
  write_csv(paste(path_version_data,
                  "dcant_inv.csv", sep = ""))

dcant_inv %>%
  filter(method != "total") %>% 
  write_csv(paste(path_version_data,
                  "dcant_inv_method.csv", sep = ""))

dcant_budget_global %>%
  write_csv(paste(path_version_data,
                  "dcant_budget_global.csv", sep = ""))

dcant_budget_basin_AIP %>%
  write_csv(paste(path_version_data,
                  "dcant_budget_basin_AIP.csv", sep = ""))

dcant_budget_basin_MLR %>%
  write_csv(paste(path_version_data,
                  "dcant_budget_basin_MLR.csv", sep = ""))

dcant_budget_lat_grid %>%
  write_csv(paste(path_version_data,
                  "dcant_budget_lat_grid.csv", sep = ""))


```


