---
title: "GLODAPv2_2021 halogenated tracers"
author: "Jens Daniel Müller"
date:  "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  workflowr::wflow_html:
    number_sections: true
    toc_depth: 3
    toc_float:
      collapsed: false
editor_options:
  chunk_output_type: console
params:
  Version_ID: "v_XXX"
---

```{r parent, child = "/nfs/kryo/work/jenmueller/emlr_cant/utilities/setup_obs.Rmd"}
# this chunk runs the code stored in setup.Rmd
# if required, please refer to instructions given here:
# https://jdblischak.github.io/workflowr/articles/wflow-07-common-code.html
```

```{r read_params_local, include = FALSE}

if (params$Version_ID == "v_XXX") {
  params_local <-
    read_rds(here::here("data/auxillary", "params_local.rds"))
  
} else {
  params_local <-
    read_rds(
      file = paste(path_root, "observations",
                   params$Version_ID,
                   "data/params_local.rds",
                   sep = "/")
    )
  }

```

```{r define_paths, include = FALSE}

path_observations <-
  paste(path_root, "/observations/", sep = "")

path_preprocessing    <-
  paste(path_observations, "preprocessing/", sep = "")

path_preprocessing_model    <-
  paste(path_root, "/model/preprocessing/", sep = "")

path_version_data     <-
  paste(path_observations,
        params_local$Version_ID,
        "/data/",
        sep = "")

```

```{r load_libraries_specific, include = FALSE}

library(lubridate)

```

```{r select_basin_mask, include=FALSE}

basinmask <- basinmask %>% 
  filter(MLR_basins == params_local$MLR_basins) %>% 
  select(-c(MLR_basins, basin_AIP))


```

# Version ID

The results displayed on this site correspond to the Version_ID:

```{r print_version_ID}

params$Version_ID

```

# Read files

Main data source for this project is the preprocessed version of GLODAPv2:


```{r print_GLODAPv2_version}

params_local$GLODAPv2_version

```


```{r read_GLODAPv2_bottle_tracer_data}

GLODAP <-
  read_csv(
    paste0(
      path_preprocessing,
      "GLODAPv2.",
      params_local$GLODAPv2_version,
      "_preprocessed_tracer.csv"),
    guess_max = 1e5
  )


```

```{r read_GLODAPv1_1_gridded_tracer_data}

pCFC_12_3d <-
  read_csv(paste(path_preprocessing,
                  "K04_pCFC_12_3d.csv", sep = ""))

```

```{r read_dcant_eMLR_3d_field}

dcant_3d <-
  read_csv(paste(path_version_data,
                 "dcant_3d.csv",
                 sep = ""))

```


```{r read_other_data}

tref <-
  read_csv(paste(path_version_data,
                 "tref.csv",
                 sep = ""))

```


# Data preparation

## Filter eras

```{r assign_eras}

# create labels for era
era_labels <- bind_cols(
  start = params_local$era_start,
  end = params_local$era_end)

era_labels <- era_labels %>% 
  mutate(start = if_else(start == -Inf, max(GLODAP$year), start),
         end = if_else(end == Inf, max(GLODAP$year), end),
         era = as.factor(paste(start, end, sep = "-")))

# filter GLODAP data within eras
GLODAP <- expand_grid(
  GLODAP,
  era_labels
)

# select data within each era
GLODAP <- GLODAP %>% 
  filter(year >= start & year <= end)

GLODAP <- GLODAP %>% 
  select(-c(start, end))

```

## Spatial boundaries

### Basin mask

The basin mask from the World Ocean Atlas was used. For details consult the data base subsection for [WOA18](https://jens-daniel-mueller.github.io/Cant_eMLR/read_World_Ocean_Atlas_2018.html) data.

Please note that some GLODAP observations were made outside the WOA18 basin mask (i.e. in marginal seas) and will be removed for further analysis.

```{r join_GLODAP_basin_mask}

# use only data inside basinmask
GLODAP <- inner_join(GLODAP, basinmask)

```


## Flags and NA

Only rows (samples) for which all relevant parameters are available were selected, ie NA's were removed.

According to Olsen et al (2020), flags within the merged master file identify:

- f:  

  - 2: Acceptable
  - 0: Interpolated (nutrients/oxygen) or calculated (CO[2] variables)
  - 9: Data not used (so, only NA data should have this flag)
  
  
- qc:  

  - 1: Adjusted or unadjusted data
  - 0: Data appear of good quality but have not been subjected to full secondary QC
  - data with poor or uncertain quality are excluded.

Following flagging criteria were taken into account:

- flag_f:     `r params_local$flag_f`
- flag_qc:    `r params_local$flag_qc`

The cleaning process was performed successively and the maps below represent the data coverage at various cleaning levels. 

Summary statistics were calculated during cleaning process.

### NA

```{r calc_NA}

GLODAP_NA <- GLODAP %>%
  select(lon, lat, era, pcfc11, pcfc12, pcfc113, pccl4, psf6) %>%
  pivot_longer(pcfc11:psf6,
               names_to = "parameter",
               values_to = "value") %>%
  mutate(NA_flag = if_else(is.na(value), "NA", "available"),
         parameter = fct_inorder(as.factor(parameter)))

GLODAP_NA_stats <- GLODAP_NA %>% 
  count(era, parameter, NA_flag)

GLODAP_NA <- GLODAP_NA %>% 
  count(lat, lon, era, parameter, NA_flag)
  
```

#### Maps

```{r NA_maps, fig.asp=1.5}

GLODAP_NA %>%
  group_split(NA_flag) %>%
  # head(1) %>%
  map(
    ~ map +
      geom_raster(data = .x,
                  aes(lon, lat, fill = n)) +
      scale_fill_viridis_c(
        option = "magma",
        direction = -1,
        trans = "log10"
      ) +
      theme(legend.position = "bottom",
            axis.text = element_blank(),
            axis.ticks = element_blank()) +
      labs(title = paste("Flag:", unique(.x$NA_flag))) +
      facet_grid(parameter ~ era)
      
  )
  
rm(GLODAP_NA)  
  
```

#### Stats

```{r NA_stats}

GLODAP_NA_stats %>% 
  ggplot(aes(parameter, n, fill = NA_flag)) +
  coord_flip() +
  scale_x_discrete(limits = rev) +
  geom_col() +
  facet_grid(era~.) +
  scale_fill_brewer(palette = "Dark2")

rm(GLODAP_NA_stats)

```



### f flag

```{r calc_f_flag}

GLODAP_f_flags <- GLODAP %>% 
  select(lon, lat, era, ends_with("f")) %>% 
  pivot_longer(cfc11f:sf6f,
               names_to = "parameter",
               values_to = "value") %>% 
  mutate(parameter = fct_inorder(as.factor(parameter)))

GLODAP_f_flags_stats <- GLODAP_f_flags %>% 
  count(era, parameter, value)

GLODAP_f_flags <- GLODAP_f_flags %>% 
  count(lat, lon, era, parameter, value)

```


#### Maps

```{r f_flag_maps, fig.asp=1.5}

GLODAP_f_flags %>%
  group_split(value) %>%
  # head(1) %>%
  map(
    ~ map +
      geom_raster(data = .x,
                  aes(lon, lat, fill = n)) +
      scale_fill_viridis_c(
        option = "magma",
        direction = -1,
        trans = "log10"
      ) +
      theme(legend.position = "bottom",
            axis.text = element_blank(),
            axis.ticks = element_blank()) +
      labs(title = paste("f flag:", unique(.x$value))) +
      facet_grid(parameter ~ era)
      
  )

rm(GLODAP_f_flags)
  
```

#### Stats

```{r f_flag_stats}

GLODAP_f_flags_stats %>% 
  mutate(value = as.factor(value)) %>% 
  ggplot(aes(parameter, n, fill = value)) +
  coord_flip() +
  scale_x_discrete(limits = rev) +
  geom_col() +
  facet_grid(era~.) +
  scale_fill_brewer(palette = "Dark2")

rm(GLODAP_f_flags_stats)

```


### qc flag

```{r calc_qc_flag}

GLODAP_qc_flags <- GLODAP %>% 
  select(lon, lat, era, ends_with("qc")) %>% 
  pivot_longer(cfc11qc:ccl4qc,
               names_to = "parameter",
               values_to = "value") %>% 
  mutate(parameter = fct_inorder(as.factor(parameter))) %>% 
  count(lat, lon, era, parameter, value)

GLODAP_qc_flags_stats <- GLODAP_qc_flags %>% 
  count(era, parameter, value)

GLODAP_qc_flags <- GLODAP_qc_flags %>% 
  count(lat, lon, era, parameter, value)

```

#### Maps

```{r qc_flag_maps, fig.asp=1.5}

GLODAP_qc_flags %>%
  group_split(value) %>%
  # head(1) %>%
  map(
    ~ map +
      geom_raster(data = .x,
                  aes(lon, lat, fill = n)) +
      scale_fill_viridis_c(
        option = "magma",
        direction = -1,
        trans = "log10"
      ) +
      theme(legend.position = "bottom",
            axis.text = element_blank(),
            axis.ticks = element_blank()) +
      labs(title = paste("qc flag:", unique(.x$value))) +
      facet_grid(parameter ~ era)
      
  )

rm(GLODAP_qc_flags)
  
```

#### Stats

```{r qc_flag_stats}

GLODAP_qc_flags_stats %>% 
  mutate(value = as.factor(value)) %>% 
  ggplot(aes(parameter, n, fill = value)) +
  coord_flip() +
  scale_x_discrete(limits = rev) +
  geom_col() +
  facet_grid(era~.) +
  scale_fill_brewer(palette = "Dark2")

rm(GLODAP_qc_flags_stats)

```


### Apply filter

```{r apply_filter, eval=FALSE}

GLODAP <- GLODAP %>%  
  filter(
    if_all(
      c(tco2, talk, params_local$MLR_predictors, depth, gamma),
      ~ !is.na(.)
    ),
    if_all(ends_with("f"), ~ . %in% params_local$flag_f),
    if_all(ends_with("qc"), ~ . %in% params_local$flag_qc)
  )

```

# Indian Ocean

```{r check_existence_IO_1990_data}

exist_IO_1990 <- GLODAP %>%
  filter(between(year, 1989, 1999) &
           basin_AIP == "Indian") %>% 
  nrow() > 0

```


## NS cruise

### Absolute

```{r cfc12_Indian_NS, eval = FALSE}

GLODAP_grid_Indian <- GLODAP %>% 
  filter(basin_AIP == "Indian",
         lon > 70,
         lon < 100,
         cruise %in% c(249, 250, 352, 353)) %>%
  mutate(cruise = as.factor(cruise)) %>% 
  distinct(era, lon, lat, cruise, year = as.factor(year(date)))

map +
  geom_tile(data = GLODAP_grid_Indian,
            aes(lon, lat, fill = year)) +
  facet_grid(era ~ .)


IO_NS <- GLODAP %>% 
  filter(cruise %in% c(249, 250, 352, 353),
         !is.na(pcfc12)) 

IO_NS %>% 
  ggplot(aes(pcfc12)) +
  geom_histogram() +
  facet_grid(era ~ .)

IO_NS %>% 
  filter(pcfc12 < 2) %>% 
  ggplot(aes(pcfc12)) +
  geom_histogram() +
  facet_grid(era ~ .)

IO_NS %>% 
  ggplot(aes(lat , depth, col = pcfc12)) +
  geom_point() +
  scale_color_viridis_c(trans = "pseudo_log",
                        breaks = c(0,10,100)) +
  scale_y_reverse() +
  facet_grid(era ~ .)

IO_NS_grid <- IO_NS %>% 
  select(lat, lon, depth, era, basin_AIP, pcfc12) %>% 
  group_by(era) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd_bottle(.x))) %>%
  select(-data) %>%
  unnest(zonal)

IO_NS_grid %>% 
  ggplot(aes(lat , depth, fill = pcfc12_mean)) +
  geom_raster() +
  scale_fill_viridis_c(trans = "pseudo_log",
                        breaks = c(0,10,100)) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  facet_grid(era ~ .)

```

### Change

```{r pcfc12_Indian_NS_offset, eval = FALSE, fig.asp=0.4}

IO_NS_grid_offset <- IO_NS_grid %>% 
  select(-pcfc12_sd) %>% 
  pivot_wider(names_from = era,
              values_from = pcfc12_mean) %>% 
  mutate(delta_pcfc12_mean := !!sym(tref$era[2]) - !!sym(tref$era[1]))

IO_NS_grid_offset %>%
  ggplot(aes(lat , depth, fill = delta_pcfc12_mean)) +
  geom_raster() +
  scale_fill_divergent(
    mid = "grey80",
    na.value = "black",
    trans = "pseudo_log",
    breaks = c(-100, -10, 0, 10, 100)
  ) +
  scale_y_reverse() +
  coord_cartesian(expand = 0)

IO_NS_grid_offset %>% 
  mutate(delta_pcfc12_mean = cut(delta_pcfc12_mean, c(-Inf, 2, 5, 20, Inf))) %>% 
  ggplot(aes(lat , depth, fill = delta_pcfc12_mean)) +
  geom_raster() +
  scale_fill_viridis_d(na.value = "grey") +
  scale_y_reverse() +
  coord_cartesian(expand = 0)

rm(IO_NS, IO_NS_grid, IO_NS_grid_offset)


```

## EW cruise

### Absolute

```{r pcfc12_Indian_EW, eval = FALSE}

GLODAP_grid_Indian <- GLODAP %>% 
  filter(basin_AIP == "Indian",
         lat > -25,
         lat < -15,
         cruise %in% c(252, 488)
         ) %>%
  mutate(cruise = as.factor(cruise)) %>% 
  distinct(era, lon, lat, cruise, year = as.factor(year(date)))

map +
  geom_tile(data = GLODAP_grid_Indian,
            aes(lon, lat, fill = year)) +
  facet_grid(era ~ .)


IO_EW <- GLODAP %>% 
  filter(cruise %in% c(252, 488),
         !is.na(pcfc12)) 

IO_EW %>% 
  ggplot(aes(pcfc12)) +
  geom_histogram() +
  facet_grid(era ~ .)

IO_EW %>% 
  filter(pcfc12 < 2) %>% 
  ggplot(aes(pcfc12)) +
  geom_histogram() +
  facet_grid(era ~ .)

IO_EW %>% 
  ggplot(aes(lon , depth, col = pcfc12)) +
  geom_point() +
  scale_fill_viridis_c(trans = "pseudo_log",
                        breaks = c(0,10,100)) +
  scale_y_reverse() +
  facet_grid(era ~ .)

IO_EW_grid <- IO_EW %>% 
  mutate(depth = cut(depth,
                          seq(0,1e4,200),
                          seq(100,1e4,200)),
         depth = as.numeric(as.character(depth)),
         lon_grid = cut(lon,
                          seq(-100,200,2),
                          seq(-99,200,2)),
         lon_grid = as.numeric(as.character(lon_grid))) %>% 
  group_by(lon_grid, depth, era) %>% 
  summarise(pcfc12 = mean(pcfc12, na.rm = TRUE)) %>% 
  ungroup()


IO_EW_grid %>% 
  ggplot(aes(lon_grid , depth, fill = pcfc12)) +
  geom_tile() +
  scale_fill_viridis_c(trans = "pseudo_log",
                        breaks = c(0,10,100)) +
  scale_y_reverse() +
  coord_cartesian(expand = 0) +
  facet_grid(era ~ .)


```

### Change

```{r pcfc12_Indian_EW_offset, eval = FALSE, fig.asp=0.4}

IO_EW_grid_offset <- IO_EW_grid %>% 
  pivot_wider(names_from = era,
              values_from = pcfc12) %>% 
  mutate(delta_pcfc12_mean := !!sym(tref$era[2]) - !!sym(tref$era[1]))


IO_EW_grid_offset %>% 
  ggplot(aes(lon_grid , depth, fill = delta_pcfc12_mean)) +
  geom_raster() +
  scale_fill_divergent(
    mid = "grey80",
    na.value = "black",
    trans = "pseudo_log",
    breaks = c(-100, -10, 0, 10, 100)
  ) +
  scale_y_reverse() +
  coord_cartesian(expand = 0)

IO_EW_grid_offset %>% 
  mutate(delta_pcfc12_mean = cut(delta_pcfc12_mean, c(-Inf, 2, 5, 20, Inf))) %>% 
  ggplot(aes(lon_grid , depth, fill = delta_pcfc12_mean)) +
  geom_raster() +
  scale_fill_viridis_d(na.value = "grey") +
  scale_y_reverse() +
  coord_cartesian(expand = 0)

rm(IO_EW, IO_EW_grid, IO_EW_grid_offset, GLODAP_grid_Indian)

```

# Zonal sections

## Absolute

```{r zonal_sections, fig.asp=1}

zonal_sections <- GLODAP %>% 
  select(lat, lon, depth, era, basin_AIP, pcfc12) %>% 
  group_by(era) %>%
  nest() %>%
  mutate(zonal = map(.x = data, ~m_zonal_mean_sd_bottle(.x))) %>%
  select(-data) %>%
  unnest(zonal)

zonal_sections %>% 
  ggplot(aes(lat , depth, fill = pcfc12_mean)) +
  geom_tile() +
  scale_fill_viridis_c(trans = "pseudo_log",
                        breaks = c(0,10,100)) +
  scale_y_reverse() +
  labs(x = "Latitude (°N)", y = "Depth (m)") +
  coord_fixed(ratio = 1e-2, expand = 0) +
  facet_grid(basin_AIP ~ era) +
  theme(legend.position = "left")


```

## Change

```{r zonal_sections_offset, fig.asp=0.6}

zonal_sections_offset <- zonal_sections %>% 
  select(-pcfc12_sd) %>% 
  pivot_wider(names_from = era,
              values_from = pcfc12_mean) %>% 
  mutate(delta_pcfc12_mean := !!sym(tref$era[2]) - !!sym(tref$era[1]))

zonal_sections_offset %>% 
  ggplot(aes(delta_pcfc12_mean)) +
  geom_histogram() +
  scale_y_log10() +
  coord_cartesian(expand = 0) +
  facet_grid(basin_AIP ~ .)


zonal_sections_offset %>% 
  ggplot(aes(delta_pcfc12_mean)) +
  geom_histogram() +
  coord_cartesian(expand = 0) +
  scale_x_continuous(trans = "pseudo_log",
                     breaks = c(-100, -10, 0, 10, 100)) +
  scale_y_log10() +
  facet_grid(basin_AIP ~ .)

zonal_sections_offset %>% 
  ggplot(aes(lat , depth, fill = delta_pcfc12_mean)) +
  geom_raster() +
  scale_fill_divergent(
    mid = "grey80",
    na.value = "black",
    trans = "pseudo_log",
    breaks = c(-100, -10, 0, 10, 100)
  ) +
  labs(x = "Latitude (°N)", y = "Depth (m)") +
  scale_y_reverse() +
  coord_fixed(ratio = 1e-2, expand = 0) +
  facet_grid(basin_AIP ~ .) +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank())


zonal_sections_offset %>%
  mutate(delta_pcfc12_mean = cut(
    delta_pcfc12_mean,
    c(-Inf, 0.2, 1, 2, 5, 20, Inf))) %>%
  ggplot(aes(lat , depth, fill = delta_pcfc12_mean)) +
  geom_raster() +
  scale_fill_viridis_d(na.value = "grey") +
  scale_y_reverse() +
  facet_grid(basin_AIP ~ .) +
  coord_fixed(ratio = 1e-2, expand = 0)

```

# Interior relation to dCant

## Distributions

```{r dcant_CFC12_correlation, fig.asp=0.5}

CFC_dcant <- inner_join(
  dcant_3d %>%
    filter(data_source == "obs") %>%
    select(lon, lat, depth, basin_AIP, dcant, gamma, gamma_slab),
  pCFC_12_3d
)

CFC_dcant <- CFC_dcant %>%
  mutate(depth_grid = cut(depth, seq(0, 1e4, 1000), right = FALSE))

```


```{r dcant_CFC12_correlation_gamma, fig.asp=2.5}

CFC_dcant %>%
  ggplot(aes(pCFC_12, dcant)) +
  geom_hline(yintercept = 0) +
  geom_bin2d() +
  geom_smooth(col = "red", se = FALSE) +
  scale_fill_viridis_c(trans = "log10") +
  facet_grid(gamma_slab ~ basin_AIP,
             scales = "free_y") +
  coord_cartesian(ylim = c(-5,15))

```

```{r dcant_CFC12_correlation_at_low_CFC, fig.asp=1.5}

CFC_dcant %>%
  filter(pCFC_12 < 5) %>% 
  ggplot(aes(dcant, col = basin_AIP, fill = basin_AIP)) +
  geom_vline(xintercept = 0) +
  geom_density(alpha = 0.3) +
  facet_grid(gamma_slab ~ .) +
  labs(title = "pCFC-12 < 5")

```

```{r dcant_CFC12_correlation_gamma_individual, fig.asp=0.5}

CFC_dcant %>%
  filter(gamma_slab %in% params_local$plot_slabs) %>% 
  group_split(gamma_slab) %>%
  map(
    ~ ggplot(data = .x,
             aes(pCFC_12, dcant)) +
      geom_hline(yintercept = 0) +
      geom_bin2d() +
      geom_smooth(col = "red", se=FALSE) +
      scale_fill_viridis_c(trans = "log10") +
      labs(title = paste("gamma_slab", unique(.x$gamma_slab))) +
      facet_grid(. ~ basin_AIP)
  )

```



```{r dcant_CFC12_correlation_at_low_CFC_gamma, fig.asp=0.5, eval=FALSE}

CFC_dcant %>%
  filter(pCFC_12 < 5) %>%
  group_split(gamma_slab) %>%
  # head(1) %>% 
  map(~ ggplot(data = .x,
               aes(dcant, col = basin_AIP, fill = basin_AIP)) +
  geom_vline(xintercept = 0) +
  geom_density(alpha = 0.3) +
  labs(title = paste("pCFC-12 < 5 | gamma_slab", unique(.x$gamma_slab))) +
  coord_cartesian(xlim = c(-4,11.5))
)

```


## Zonal sections

```{r zonal_mean_sections, fig.asp=1}

CFC_dcant_zonal <- m_zonal_mean_sd(
  CFC_dcant %>% 
    select(lat, lon, depth, basin_AIP, gamma, dcant, pCFC_12)
)


CFC_dcant_zonal <- CFC_dcant_zonal %>%
  mutate(
    dcant_mean_pos = if_else(dcant_mean < 0, 0, dcant_mean),
    dcant_per_CFC = dcant_mean_pos / pCFC_12_mean,
    dcant_per_CFC_log = log10(dcant_per_CFC)
  )

# dcant_per_CFC_log_min <- CFC_dcant_zonal %>% 
#   filter(dcant_per_CFC_log != -Inf) %>% 
#   slice_min(dcant_per_CFC_log) %>% 
#   pull(dcant_per_CFC_log)
# 
# dcant_per_CFC_log_max <- CFC_dcant_zonal %>% 
#   filter(dcant_per_CFC_log != Inf) %>% 
#   slice_max(dcant_per_CFC_log) %>% 
#   pull(dcant_per_CFC_log)
# 
# 
# CFC_dcant_zonal <- CFC_dcant_zonal %>%
#   mutate(
#     dcant_per_CFC_log = if_else(dcant_mean_pos == 0,
#                                 dcant_per_CFC_log_min,
#                                 dcant_per_CFC_log),
#     dcant_per_CFC_log = if_else(
#       pCFC_12_mean == 0,
#       dcant_per_CFC_log_max,
#       dcant_per_CFC_log
#     )
#   )


CFC_dcant_zonal %>%
  p_section_zonal_continous_depth(
    var = "dcant_mean_pos",
    title_text = NULL) +
  facet_grid(basin_AIP ~ .)


CFC_dcant_zonal %>%
  p_section_zonal_continous_depth(
    var = "pCFC_12_mean",
    breaks = NULL,
    legend_title = "pCFC_12",
    title_text = NULL
  ) +
  facet_grid(basin_AIP ~ .)


CFC_dcant_zonal %>%
  mutate(lg_pCFC_12_mean = log10(pCFC_12_mean)) %>% 
  p_section_zonal_continous_depth(
    var = "lg_pCFC_12_mean",
    breaks = NULL,
    legend_title = "pCFC_12",
    title_text = NULL
  ) +
  facet_grid(basin_AIP ~ .)


CFC_dcant_zonal %>%
  # filter(dcant_per_CFC_log > -4) %>%
  p_section_zonal_continous_depth(
    var = "dcant_per_CFC_log",
    breaks = NULL,
    legend_title = "log10\ndcant /\npCFC_12",
    title_text = NULL
  ) +
  facet_grid(basin_AIP ~ .)

CFC_dcant_zonal %>%
  # filter(dcant_per_CFC_log > -4) %>%
  p_section_zonal_continous_depth(
    var = "dcant_per_CFC_log",
    breaks = NULL,
    legend_title = "log10\ndcant /\npCFC_12",
    title_text = NULL
  ) +
  scale_y_reverse(
    limits = c(1000, 0),
    breaks = seq(0, 900, 200),
    name = "Depth (m)"
  ) +
  facet_grid(basin_AIP ~ .)

```



# Overview plots

## Number of overservations

```{r counts}

GLODAP %>% 
  filter(!is.na(pcfc12)) %>% 
  group_by(era, basin_AIP) %>% 
  count() %>% 
  ggplot(aes(basin_AIP, n, fill = era)) +
  geom_col() +
  scale_fill_brewer(palette = "Dark2")

```

## Coverage maps by era

### Final input data

The following plots show the remaining data density in each grid cell **after all cleaning steps**, separately for each era.

```{r coverage_maps_era_clean, fig.asp=1}

map +
  geom_bin2d(data = GLODAP %>% filter(!is.na(pcfc12)),
             aes(lon, lat),
             binwidth = c(1,1)) +
  scale_fill_viridis_c(option = "magma", direction = -1, trans = "log10") +
  facet_wrap(~era, ncol = 1) +
  labs(title = "GLODAP observations",
       subtitle = paste("Version:", params_local$Version_ID)) +
  theme(axis.title = element_blank())

```









